# è·³è¡¨é¡¹ç›®å¤šçº¿ç¨‹ç¼–ç¨‹æ•™å­¦æ–‡æ¡£

## ç›®å½•
- [ä¸€ã€é¡¹ç›®ä¸­çš„å¤šçº¿ç¨‹åº”ç”¨æ¦‚è§ˆ](#ä¸€é¡¹ç›®ä¸­çš„å¤šçº¿ç¨‹åº”ç”¨æ¦‚è§ˆ)
- [äºŒã€åŸç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°](#äºŒåŸç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°)
- [ä¸‰ã€ä¼˜åŒ–ç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°](#ä¸‰ä¼˜åŒ–ç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°)
- [å››ã€å‹åŠ›æµ‹è¯•ä¸­çš„å¤šçº¿ç¨‹](#å››å‹åŠ›æµ‹è¯•ä¸­çš„å¤šçº¿ç¨‹)
- [äº”ã€æµ‹è¯•ç¨‹åºä¸­çš„å¤šçº¿ç¨‹](#äº”æµ‹è¯•ç¨‹åºä¸­çš„å¤šçº¿ç¨‹)
- [å…­ã€å¤šçº¿ç¨‹ç¼–ç¨‹æ ¸å¿ƒæ¦‚å¿µ](#å…­å¤šçº¿ç¨‹ç¼–ç¨‹æ ¸å¿ƒæ¦‚å¿µ)
- [ä¸ƒã€å®æˆ˜æ¡ˆä¾‹ä¸æœ€ä½³å®è·µ](#ä¸ƒå®æˆ˜æ¡ˆä¾‹ä¸æœ€ä½³å®è·µ)

---

## ä¸€ã€é¡¹ç›®ä¸­çš„å¤šçº¿ç¨‹åº”ç”¨æ¦‚è§ˆ

æœ¬é¡¹ç›®åœ¨ä»¥ä¸‹å‡ ä¸ªæ¨¡å—ä¸­ä½¿ç”¨äº†å¤šçº¿ç¨‹æŠ€æœ¯ï¼š

### 1.1 å¤šçº¿ç¨‹ä½¿ç”¨ä½ç½®

| æ–‡ä»¶ | å¤šçº¿ç¨‹æŠ€æœ¯ | ç”¨é€” |
|------|-----------|------|
| `skiplist.h` | `std::mutex` | å…¨å±€äº’æ–¥é”ä¿æŠ¤è·³è¡¨æ“ä½œ |
| `skiplist_optimized.h` | å¤šå±‚é”æœºåˆ¶ | åˆ†æ®µé” + å±‚çº§é” + è®¡æ•°é” |
| `segment_lock.h` | `std::mutex` æ•°ç»„ | åˆ†æ®µé”ç®¡ç†å™¨ |
| `memory_pool.h` | `std::mutex` | ä¿æŠ¤å†…å­˜æ± å¹¶å‘è®¿é—® |
| `test_optimized.cpp` | `std::thread` | å¤šçº¿ç¨‹æ€§èƒ½æµ‹è¯• |
| `stress-test/stress_test.cpp` | `pthread` | å‹åŠ›æµ‹è¯• |

### 1.2 å¤šçº¿ç¨‹æŠ€æœ¯æ ˆ

**C++11 æ ‡å‡†åº“**ï¼š
- `std::mutex` - äº’æ–¥é”
- `std::lock_guard` - RAIIé”ç®¡ç†
- `std::unique_lock` - çµæ´»çš„é”ç®¡ç†
- `std::thread` - çº¿ç¨‹ç±»

**POSIXçº¿ç¨‹ï¼ˆpthreadï¼‰**ï¼š
- `pthread_create` - åˆ›å»ºçº¿ç¨‹
- `pthread_join` - ç­‰å¾…çº¿ç¨‹ç»“æŸ
- `pthread_exit` - é€€å‡ºçº¿ç¨‹

---

## äºŒã€åŸç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°

### 2.1 å…¨å±€äº’æ–¥é”è®¾è®¡

**æ–‡ä»¶ï¼š`skiplist.h`**

```cpp
#include <mutex>

std::mutex mtx;  // å…¨å±€äº’æ–¥é”

template<typename K, typename V>
class SkipList {
    // ...
};
```

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨å•ä¸ªå…¨å±€é”ä¿æŠ¤æ‰€æœ‰æ“ä½œ
- ç®€å•ç›´æ¥ï¼Œæ˜“äºç†è§£
- ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä½†æ€§èƒ½è¾ƒå·®

### 2.2 æ’å…¥æ“ä½œçš„çº¿ç¨‹å®‰å…¨

```cpp
template<typename K, typename V>
int SkipList<K, V>::insert_element(const K key, const V value) {
    mtx.lock();  // ğŸ”’ åŠ é”
    
    Node<K, V> *current = this->_header;
    Node<K, V> *update[_max_level+1];
    memset(update, 0, sizeof(Node<K, V>*)*(_max_level+1));

    // æŸ¥æ‰¾æ’å…¥ä½ç½®
    for(int i = _skip_list_level; i >= 0; i--) {
        while(current->forward[i] != NULL && 
              current->forward[i]->get_key() < key) {
            current = current->forward[i]; 
        }
        update[i] = current;
    }

    current = current->forward[0];

    // æ£€æŸ¥keyæ˜¯å¦å·²å­˜åœ¨
    if (current != NULL && current->get_key() == key) {
        std::cout << "key: " << key << ", exists" << std::endl;
        mtx.unlock();  // ğŸ”“ è§£é”
        return 1;
    }

    // æ’å…¥æ–°èŠ‚ç‚¹
    if (current == NULL || current->get_key() != key) {
        int random_level = get_random_level();

        if (random_level > _skip_list_level) {
            for (int i = _skip_list_level+1; i < random_level+1; i++) {
                update[i] = _header;
            }
            _skip_list_level = random_level;
        }

        Node<K, V>* inserted_node = create_node(key, value, random_level);
        
        for (int i = 0; i <= random_level; i++) {
            inserted_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = inserted_node;
        }
        
        std::cout << "Successfully inserted key:" << key << std::endl;
        _element_count++;
    }
    
    mtx.unlock();  // ğŸ”“ è§£é”
    return 0;
}
```

**å…³é”®ç‚¹**ï¼š
1. **åŠ é”æ—¶æœº**ï¼šå‡½æ•°å¼€å§‹æ—¶ç«‹å³åŠ é”
2. **è§£é”æ—¶æœº**ï¼šå‡½æ•°è¿”å›å‰è§£é”ï¼ˆæ³¨æ„å¤šä¸ªè¿”å›ç‚¹éƒ½è¦è§£é”ï¼‰
3. **ä¸´ç•ŒåŒº**ï¼šæ•´ä¸ªæ’å…¥é€»è¾‘éƒ½åœ¨é”ä¿æŠ¤ä¸‹
4. **é—®é¢˜**ï¼šæ‰€æœ‰çº¿ç¨‹ä¸²è¡Œæ‰§è¡Œï¼Œæ— æ³•å¹¶å‘

### 2.3 åˆ é™¤æ“ä½œçš„çº¿ç¨‹å®‰å…¨

```cpp
template<typename K, typename V> 
void SkipList<K, V>::delete_element(K key) {
    mtx.lock();  // ğŸ”’ åŠ é”
    
    Node<K, V> *current = this->_header; 
    Node<K, V> *update[_max_level+1];
    memset(update, 0, sizeof(Node<K, V>*)*(_max_level+1));

    // æŸ¥æ‰¾åˆ é™¤ä½ç½®
    for (int i = _skip_list_level; i >= 0; i--) {
        while (current->forward[i] !=NULL && 
               current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
        update[i] = current;
    }

    current = current->forward[0];
    
    if (current != NULL && current->get_key() == key) {
        // åˆ é™¤èŠ‚ç‚¹
        for (int i = 0; i <= _skip_list_level; i++) {
            if (update[i]->forward[i] != current) 
                break;
            update[i]->forward[i] = current->forward[i];
        }

        // æ›´æ–°å±‚çº§
        while (_skip_list_level > 0 && 
               _header->forward[_skip_list_level] == 0) {
            _skip_list_level--; 
        }

        std::cout << "Successfully deleted key "<< key << std::endl;
        delete current;
        _element_count--;
    }
    
    mtx.unlock();  // ğŸ”“ è§£é”
    return;
}
```

**å…³é”®ç‚¹**ï¼š
- ä¸æ’å…¥æ“ä½œç±»ä¼¼çš„é”æœºåˆ¶
- æ•´ä¸ªåˆ é™¤è¿‡ç¨‹åœ¨é”ä¿æŠ¤ä¸‹
- ä¿è¯çº¿ç¨‹å®‰å…¨ä½†ç‰ºç‰²å¹¶å‘æ€§èƒ½

### 2.4 æŸ¥è¯¢æ“ä½œï¼ˆæ— é”ï¼‰

```cpp
template<typename K, typename V> 
bool SkipList<K, V>::search_element(K key) {
    std::cout << "search_element-----------------" << std::endl;
    Node<K, V> *current = _header;

    // æ³¨æ„ï¼šåŸç‰ˆæŸ¥è¯¢æ“ä½œæ²¡æœ‰åŠ é”ï¼
    for (int i = _skip_list_level; i >= 0; i--) {
        while (current->forward[i] && current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
    }

    current = current->forward[0];

    if (current and current->get_key() == key) {
        std::cout << "Found key: " << key << std::endl;
        return true;
    }

    std::cout << "Not Found Key:" << key << std::endl;
    return false;
}
```

**é—®é¢˜åˆ†æ**ï¼š
- æŸ¥è¯¢æ“ä½œæ²¡æœ‰åŠ é”
- åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯èƒ½è¯»åˆ°ä¸ä¸€è‡´çš„æ•°æ®
- å¦‚æœå…¶ä»–çº¿ç¨‹æ­£åœ¨ä¿®æ”¹ç»“æ„ï¼Œå¯èƒ½å¯¼è‡´å´©æºƒ

### 2.5 åŸç‰ˆå¤šçº¿ç¨‹çš„ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**ï¼š
- âœ… å®ç°ç®€å•ï¼Œæ˜“äºç†è§£
- âœ… ä¿è¯å†™æ“ä½œçš„çº¿ç¨‹å®‰å…¨
- âœ… ä¸ä¼šå‡ºç°æ•°æ®ç«äº‰ï¼ˆå†™æ“ä½œï¼‰

**ç¼ºç‚¹**ï¼š
- âŒ å…¨å±€é”å¯¼è‡´æ‰€æœ‰æ“ä½œä¸²è¡ŒåŒ–
- âŒ å¤šçº¿ç¨‹æ€§èƒ½æå‡æœ‰é™
- âŒ æŸ¥è¯¢æ“ä½œæœªåŠ é”ï¼Œå­˜åœ¨å®‰å…¨éšæ‚£
- âŒ é”ç²’åº¦å¤ªç²—ï¼Œæµªè´¹CPUèµ„æº

---

## ä¸‰ã€ä¼˜åŒ–ç‰ˆè·³è¡¨çš„å¤šçº¿ç¨‹å®ç°

### 3.1 å¤šå±‚é”æ¶æ„

**æ–‡ä»¶ï¼š`skiplist_optimized.h`**

```cpp
template <typename K, typename V> 
class SkipListOptimized {
private:
    // 1. åˆ†æ®µé”ç®¡ç†å™¨ï¼ˆæ ¸å¿ƒä¼˜åŒ–ï¼‰
    SegmentLockManager<K> _lock_manager;
    
    // 2. å±‚çº§é”ï¼ˆä¿æŠ¤ _skip_list_levelï¼‰
    std::mutex _level_mutex;
    
    // 3. è®¡æ•°é”ï¼ˆä¿æŠ¤ _element_countï¼‰
    std::mutex _count_mutex;
    
    // 4. å…¨å±€é”ï¼ˆä¿æŠ¤å…¨å±€æ“ä½œå¦‚displayï¼‰
    std::mutex _global_mutex;
    
public:
    SkipListOptimized(int max_level, int segment_count = 16)
        : _lock_manager(segment_count) {
        // ...
    }
};
```

**é”çš„å±‚æ¬¡ç»“æ„**ï¼š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     SkipListOptimized               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  _lock_manager (åˆ†æ®µé”)             â”‚
â”‚    â”œâ”€ Segment 0 Lock                â”‚
â”‚    â”œâ”€ Segment 1 Lock                â”‚
â”‚    â””â”€ ...                            â”‚
â”‚                                      â”‚
â”‚  _level_mutex (å±‚çº§é”)              â”‚
â”‚  _count_mutex (è®¡æ•°é”)              â”‚
â”‚  _global_mutex (å…¨å±€é”)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 åˆ†æ®µé”ç®¡ç†å™¨

**æ–‡ä»¶ï¼š`segment_lock.h`**

```cpp
template<typename K>
class SegmentLockManager {
private:
    int _segment_count;           // æ®µæ•°é‡ï¼ˆé»˜è®¤16ï¼‰
    std::mutex* _segment_locks;   // é”æ•°ç»„
    
public:
    explicit SegmentLockManager(int segment_count = 16) 
        : _segment_count(segment_count) {
        _segment_locks = new std::mutex[segment_count];
    }
    
    ~SegmentLockManager() {
        delete[] _segment_locks;
    }
    
    // è®¡ç®—keyæ‰€å±çš„æ®µç´¢å¼•
    int get_segment_index(const K& key) const {
        size_t hash_value = std::hash<K>{}(key);
        return hash_value % _segment_count;
    }
    
    // è·å–å†™é”
    std::unique_lock<std::mutex> get_write_lock(int segment_index) {
        return std::unique_lock<std::mutex>(_segment_locks[segment_index]);
    }
    
    // è·å–è¯»é”
    std::unique_lock<std::mutex> get_read_lock(int segment_index) {
        return std::unique_lock<std::mutex>(_segment_locks[segment_index]);
    }
    
    // è·å–æ‰€æœ‰æ®µçš„é”
    std::vector<std::unique_lock<std::mutex>> get_all_write_locks() {
        std::vector<std::unique_lock<std::mutex>> locks;
        locks.reserve(_segment_count);
        
        // æŒ‰é¡ºåºè·å–ï¼Œé¿å…æ­»é”
        for (int i = 0; i < _segment_count; i++) {
            locks.emplace_back(_segment_locks[i]);
        }
        return locks;
    }
};
```

**å…³é”®æŠ€æœ¯**ï¼š
1. **å“ˆå¸Œåˆ†æ®µ**ï¼šä½¿ç”¨`std::hash`å°†keyå‡åŒ€åˆ†é…åˆ°å„æ®µ
2. **RAIIé”ç®¡ç†**ï¼šè¿”å›`std::unique_lock`å¯¹è±¡ï¼Œè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
3. **æ­»é”é¢„é˜²**ï¼šæŒ‰é¡ºåºè·å–å¤šä¸ªé”

### 3.3 æ’å…¥æ“ä½œçš„ç»†ç²’åº¦é”

```cpp
template<typename K, typename V>
int SkipListOptimized<K, V>::insert_element(const K key, const V value) {
    // 1. è·å–keyæ‰€å±æ®µçš„å†™é”ï¼ˆåªé”ä¸€ä¸ªæ®µï¼‰
    int segment_index = _lock_manager.get_segment_index(key);
    auto lock = _lock_manager.get_write_lock(segment_index);
    
    // 2. è·å–å±‚çº§é”ï¼ˆä¿æŠ¤ _skip_list_levelï¼‰
    std::lock_guard<std::mutex> level_lock(_level_mutex);
    
    NodeOpt<K, V> *current = this->_header;
    std::vector<NodeOpt<K, V>*> update(_max_level+1, nullptr);

    // 3. æŸ¥æ‰¾æ’å…¥ä½ç½®
    for(int i = _skip_list_level; i >= 0; i--) {
        while(current->forward[i] != NULL && 
              current->forward[i]->get_key() < key) {
            current = current->forward[i]; 
        }
        update[i] = current;
    }

    current = current->forward[0];

    // 4. æ£€æŸ¥keyæ˜¯å¦å·²å­˜åœ¨
    if (current != NULL && current->get_key() == key) {
        std::cout << "key: " << key << ", exists" << std::endl;
        return 1;
    }

    // 5. æ’å…¥æ–°èŠ‚ç‚¹
    if (current == NULL || current->get_key() != key) {
        int random_level = get_random_level();

        if (random_level > _skip_list_level) {
            for (int i = _skip_list_level+1; i < random_level+1; i++) {
                update[i] = _header;
            }
            _skip_list_level = random_level;
        }

        // ä½¿ç”¨å†…å­˜æ± åˆ›å»ºèŠ‚ç‚¹
        NodeOpt<K, V>* inserted_node = create_node(key, value, random_level);
        
        for (int i = 0; i <= random_level; i++) {
            inserted_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = inserted_node;
        }
        
        std::cout << "Successfully inserted key:" << key << std::endl;
        
        // 6. æ›´æ–°è®¡æ•°ï¼ˆéœ€è¦å•ç‹¬åŠ é”ï¼‰
        {
            std::lock_guard<std::mutex> count_lock(_count_mutex);
            _element_count++;
        }
    }
    
    return 0;
}
```

**å¹¶å‘ä¼˜åŠ¿**ï¼š
```
åœºæ™¯ï¼š3ä¸ªçº¿ç¨‹åŒæ—¶æ’å…¥

çº¿ç¨‹Aæ’å…¥key=5  â†’ hash(5) % 16 = 5  â†’ é”Segment 5
çº¿ç¨‹Bæ’å…¥key=18 â†’ hash(18) % 16 = 2 â†’ é”Segment 2  âœ“ å¯ä»¥å¹¶å‘
çº¿ç¨‹Cæ’å…¥key=23 â†’ hash(23) % 16 = 7 â†’ é”Segment 7  âœ“ å¯ä»¥å¹¶å‘

åŸç‰ˆï¼š3ä¸ªçº¿ç¨‹ä¸²è¡Œæ‰§è¡Œï¼Œæ€»è€—æ—¶ = 3T
ä¼˜åŒ–ç‰ˆï¼š3ä¸ªçº¿ç¨‹å¹¶å‘æ‰§è¡Œï¼Œæ€»è€—æ—¶ â‰ˆ T
```

### 3.4 æŸ¥è¯¢æ“ä½œçš„è¯»é”

```cpp
template<typename K, typename V> 
bool SkipListOptimized<K, V>::search_element(K key) {
    std::cout << "search_element-----------------" << std::endl;
    
    // 1. è·å–keyæ‰€å±æ®µçš„è¯»é”
    int segment_index = _lock_manager.get_segment_index(key);
    auto lock = _lock_manager.get_read_lock(segment_index);
    
    // 2. å¿«é€Ÿè¯»å–å½“å‰å±‚çº§
    int current_level;
    {
        std::lock_guard<std::mutex> level_lock(_level_mutex);
        current_level = _skip_list_level;
    }
    
    // 3. æ‰§è¡ŒæŸ¥è¯¢
    NodeOpt<K, V> *current = _header;

    for (int i = current_level; i >= 0; i--) {
        while (current->forward[i] && current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
    }

    current = current->forward[0];

    if (current and current->get_key() == key) {
        std::cout << "Found key: " << key << std::endl;
        return true;
    }

    std::cout << "Not Found Key:" << key << std::endl;
    return false;
}
```

**ä¼˜åŒ–ç‚¹**ï¼š
- ä½¿ç”¨è¯»é”ï¼ˆå½“å‰å®ç°ä¸ºmutexï¼Œå¯æ‰©å±•ä¸ºshared_mutexï¼‰
- å¿«é€Ÿè¯»å–å±‚çº§åç«‹å³é‡Šæ”¾å±‚çº§é”
- å‡å°‘é”æŒæœ‰æ—¶é—´

### 3.5 åˆ é™¤æ“ä½œçš„ç»†ç²’åº¦é”

```cpp
template<typename K, typename V> 
void SkipListOptimized<K, V>::delete_element(K key) {
    // 1. è·å–keyæ‰€å±æ®µçš„å†™é”
    int segment_index = _lock_manager.get_segment_index(key);
    auto lock = _lock_manager.get_write_lock(segment_index);
    
    // 2. è·å–å±‚çº§é”
    std::lock_guard<std::mutex> level_lock(_level_mutex);
    
    NodeOpt<K, V> *current = this->_header; 
    std::vector<NodeOpt<K, V>*> update(_max_level+1, nullptr);

    // 3. æŸ¥æ‰¾åˆ é™¤ä½ç½®
    for (int i = _skip_list_level; i >= 0; i--) {
        while (current->forward[i] != NULL && 
               current->forward[i]->get_key() < key) {
            current = current->forward[i];
        }
        update[i] = current;
    }

    current = current->forward[0];

    // 4. åˆ é™¤èŠ‚ç‚¹
    if (current != NULL && current->get_key() == key) {
        for (int i = 0; i <= _skip_list_level; i++) {
            if (update[i]->forward[i] != current) 
                break;
            update[i]->forward[i] = current->forward[i];
        }

        delete current;
        
        // 5. æ›´æ–°è®¡æ•°
        {
            std::lock_guard<std::mutex> count_lock(_count_mutex);
            _element_count--;
        }

        // 6. æ›´æ–°å±‚çº§
        while (_skip_list_level > 0 && 
               _header->forward[_skip_list_level] == 0) {
            _skip_list_level--; 
        }

        std::cout << "Successfully deleted key "<< key << std::endl;
    }
}
```

### 3.6 å…¨å±€æ“ä½œçš„é”ç­–ç•¥

```cpp
template<typename K, typename V> 
void SkipListOptimized<K, V>::display_list() {
    // 1. è·å–å…¨å±€é”
    std::lock_guard<std::mutex> lock(_global_mutex);
    
    // 2. è·å–æ‰€æœ‰æ®µçš„é”
    auto locks = _lock_manager.get_all_write_locks();
    
    // 3. è¯»å–å½“å‰å±‚çº§
    int current_level;
    {
        std::lock_guard<std::mutex> level_lock(_level_mutex);
        current_level = _skip_list_level;
    }
    
    // 4. æ˜¾ç¤ºè·³è¡¨
    std::cout << "\n*****Skip List (Optimized)*****"<<"\n"; 
    for (int i = 0; i <= current_level; i++) {
        NodeOpt<K, V> *node = this->_header->forward[i]; 
        std::cout << "Level " << i << ": ";
        while (node != NULL) {
            std::cout << node->get_key() << ":" << node->get_value() << ";";
            node = node->forward[i];
        }
        std::cout << std::endl;
    }
}
```

**å…³é”®ç‚¹**ï¼š
- éœ€è¦è®¿é—®æ‰€æœ‰æ•°æ®çš„æ“ä½œå¿…é¡»è·å–æ‰€æœ‰æ®µçš„é”
- æŒ‰é¡ºåºè·å–é”é¿å…æ­»é”
- ä½¿ç”¨å…¨å±€é”é˜²æ­¢å¤šä¸ªå…¨å±€æ“ä½œå¹¶å‘

### 3.7 å†…å­˜æ± çš„çº¿ç¨‹å®‰å…¨

**æ–‡ä»¶ï¼š`memory_pool.h`**

```cpp
template<typename K, typename V>
class NodeMemoryPool {
private:
    std::vector<NodeOpt<K, V>*> _free_list;
    mutable std::mutex _pool_mutex;  // ä¿æŠ¤å†…å­˜æ± 
    
public:
    // åˆ†é…èŠ‚ç‚¹ - çº¿ç¨‹å®‰å…¨
    NodeOpt<K, V>* allocate(const K& key, const V& value, int level) {
        std::lock_guard<std::mutex> lock(_pool_mutex);  // ğŸ”’ åŠ é”
        
        NodeOpt<K, V>* node = nullptr;
        
        if (!_free_list.empty()) {
            node = _free_list.back();
            _free_list.pop_back();
            reinitialize_node(node, key, value, level);
            _reused_count++;
        } else {
            node = new NodeOpt<K, V>(key, value, level);
            _allocated_count++;
        }
        
        return node;
    }  // ğŸ”“ è‡ªåŠ¨è§£é”
    
    // å›æ”¶èŠ‚ç‚¹ - çº¿ç¨‹å®‰å…¨
    void deallocate(NodeOpt<K, V>* node) {
        if (node == nullptr) return;
        
        std::lock_guard<std::mutex> lock(_pool_mutex);  // ğŸ”’ åŠ é”
        _free_list.push_back(node);
    }  // ğŸ”“ è‡ªåŠ¨è§£é”
};
```

**çº¿ç¨‹å®‰å…¨ä¿è¯**ï¼š
- ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤ç©ºé—²åˆ—è¡¨
- ä½¿ç”¨`std::lock_guard`è‡ªåŠ¨ç®¡ç†é”
- æ‰€æœ‰å…¬å…±æ–¹æ³•éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„

---

## å››ã€å‹åŠ›æµ‹è¯•ä¸­çš„å¤šçº¿ç¨‹

### 4.1 ä½¿ç”¨pthreadè¿›è¡Œå‹åŠ›æµ‹è¯•

**æ–‡ä»¶ï¼š`stress-test/stress_test.cpp`**

```cpp
#include <pthread.h>
#include "../skiplist.h"

#define NUM_THREADS 1
#define TEST_COUNT 100000

SkipList<int, std::string> skipList(18);

// çº¿ç¨‹å‡½æ•°ï¼šæ’å…¥å…ƒç´ 
void *insertElement(void* threadid) {
    long tid = (long)threadid;
    std::cout << tid << std::endl;  
    
    int tmp = TEST_COUNT / NUM_THREADS; 
    for (int i = tid * tmp, count = 0; count < tmp; i++) {
        count++;
        skipList.insert_element(rand() % TEST_COUNT, "a"); 
    }
    
    pthread_exit(NULL);
}

int main() {
    srand(time(NULL));
    
    pthread_t threads[NUM_THREADS];
    int rc;
    
    auto start = std::chrono::high_resolution_clock::now();

    // åˆ›å»ºçº¿ç¨‹
    for(int i = 0; i < NUM_THREADS; i++) {
        std::cout << "main() : creating thread, " << i << std::endl;
        rc = pthread_create(&threads[i], NULL, insertElement, (void *)i);

        if (rc) {
            std::cout << "Error:unable to create thread," << rc << std::endl;
            exit(-1);
        }
    }

    // ç­‰å¾…çº¿ç¨‹å®Œæˆ
    void *ret;
    for(int i = 0; i < NUM_THREADS; i++) {
        if (pthread_join(threads[i], &ret) != 0) {
            perror("pthread_create() error"); 
            exit(3);
        }
    }
    
    auto finish = std::chrono::high_resolution_clock::now(); 
    std::chrono::duration<double> elapsed = finish - start;
    std::cout << "insert elapsed:" << elapsed.count() << std::endl;

    pthread_exit(NULL);
    return 0;
}
```

### 4.2 pthread APIè¯¦è§£

#### pthread_create - åˆ›å»ºçº¿ç¨‹

```cpp
int pthread_create(pthread_t *thread,           // çº¿ç¨‹ID
                   const pthread_attr_t *attr,  // çº¿ç¨‹å±æ€§ï¼ˆNULLä¸ºé»˜è®¤ï¼‰
                   void *(*start_routine)(void*), // çº¿ç¨‹å‡½æ•°
                   void *arg);                  // ä¼ é€’ç»™çº¿ç¨‹å‡½æ•°çš„å‚æ•°
```

**ç¤ºä¾‹**ï¼š
```cpp
pthread_t thread;
int thread_id = 5;

// åˆ›å»ºçº¿ç¨‹ï¼Œæ‰§è¡ŒinsertElementå‡½æ•°ï¼Œä¼ é€’å‚æ•°5
int rc = pthread_create(&thread, NULL, insertElement, (void*)(long)thread_id);

if (rc != 0) {
    std::cout << "åˆ›å»ºçº¿ç¨‹å¤±è´¥" << std::endl;
}
```

#### pthread_join - ç­‰å¾…çº¿ç¨‹ç»“æŸ

```cpp
int pthread_join(pthread_t thread,  // è¦ç­‰å¾…çš„çº¿ç¨‹ID
                 void **retval);    // æ¥æ”¶çº¿ç¨‹è¿”å›å€¼ï¼ˆNULLè¡¨ç¤ºä¸å…³å¿ƒï¼‰
```

**ç¤ºä¾‹**ï¼š
```cpp
void *return_value;
pthread_join(thread, &return_value);  // é˜»å¡ç­‰å¾…çº¿ç¨‹ç»“æŸ
std::cout << "çº¿ç¨‹å·²ç»“æŸ" << std::endl;
```

#### pthread_exit - é€€å‡ºçº¿ç¨‹

```cpp
void pthread_exit(void *retval);  // çº¿ç¨‹è¿”å›å€¼
```

**ç¤ºä¾‹**ï¼š
```cpp
void *thread_function(void *arg) {
    // æ‰§è¡Œä»»åŠ¡...
    
    pthread_exit(NULL);  // é€€å‡ºçº¿ç¨‹
}
```

### 4.3 pthread vs std::thread

| ç‰¹æ€§ | pthread | std::thread |
|------|---------|-------------|
| æ ‡å‡† | POSIXæ ‡å‡† | C++11æ ‡å‡† |
| è·¨å¹³å° | ä»…Unix/Linux | è·¨å¹³å° |
| æ˜“ç”¨æ€§ | è¾ƒå¤æ‚ | ç®€å•æ˜“ç”¨ |
| ç±»å‹å®‰å…¨ | å¦ï¼ˆvoid*ï¼‰ | æ˜¯ï¼ˆæ¨¡æ¿ï¼‰ |
| RAII | å¦ | æ˜¯ |

**å»ºè®®**ï¼šæ–°é¡¹ç›®ä¼˜å…ˆä½¿ç”¨`std::thread`

---

## äº”ã€æµ‹è¯•ç¨‹åºä¸­çš„å¤šçº¿ç¨‹

### 5.1 ä½¿ç”¨std::threadè¿›è¡Œæµ‹è¯•

**æ–‡ä»¶ï¼š`test_optimized.cpp`**

```cpp
#include <thread>
#include <vector>

#define NUM_THREADS 8
#define TEST_COUNT 10000

// å¤šçº¿ç¨‹æ’å…¥å‡½æ•°
void thread_insert_optimized(SkipListOptimized<int, std::string>* skipList, 
                             int thread_id, int count) {
    int start = thread_id * count;
    for (int i = 0; i < count; i++) {
        skipList->insert_element(start + i, "value_" + std::to_string(start + i));
    }
}

// å¤šçº¿ç¨‹æ’å…¥æµ‹è¯•
void test_optimized_concurrent_insert() {
    std::cout << "\n========== ä¼˜åŒ–ç‰ˆè·³è¡¨å¤šçº¿ç¨‹æ’å…¥æµ‹è¯• ==========" << std::endl;
    SkipListOptimized<int, std::string> skipList(18, 16);
    
    std::vector<std::thread> threads;
    int count_per_thread = TEST_COUNT / NUM_THREADS;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // åˆ›å»ºçº¿ç¨‹
    for (int i = 0; i < NUM_THREADS; i++) {
        threads.emplace_back(thread_insert_optimized, &skipList, i, count_per_thread);
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "ä½¿ç”¨ " << NUM_THREADS << " ä¸ªçº¿ç¨‹æ’å…¥ " << TEST_COUNT << " ä¸ªå…ƒç´ " << std::endl;
    std::cout << "æ€»è€—æ—¶: " << duration.count() << " ms" << std::endl;
    std::cout << "QPS: " << (TEST_COUNT * 1000.0 / duration.count()) << std::endl;
}
```

### 5.2 std::threadè¯¦è§£

#### åˆ›å»ºçº¿ç¨‹

```cpp
#include <thread>

// æ–¹å¼1ï¼šä½¿ç”¨å‡½æ•°æŒ‡é’ˆ
void my_function(int arg) {
    std::cout << "çº¿ç¨‹å‚æ•°: " << arg << std::endl;
}

std::thread t1(my_function, 42);

// æ–¹å¼2ï¼šä½¿ç”¨lambdaè¡¨è¾¾å¼
std::thread t2([]() {
    std::cout << "Lambdaçº¿ç¨‹" << std::endl;
});

// æ–¹å¼3ï¼šä½¿ç”¨æˆå‘˜å‡½æ•°
class MyClass {
public:
    void member_function(int arg) {
        std::cout << "æˆå‘˜å‡½æ•°: " << arg << std::endl;
    }
};

MyClass obj;
std::thread t3(&MyClass::member_function, &obj, 100);
```

#### ç­‰å¾…çº¿ç¨‹å®Œæˆ

```cpp
std::thread t(my_function, 42);

// æ–¹å¼1ï¼šjoin - é˜»å¡ç­‰å¾…çº¿ç¨‹ç»“æŸ
t.join();

// æ–¹å¼2ï¼šdetach - åˆ†ç¦»çº¿ç¨‹ï¼Œè®©å…¶åœ¨åå°è¿è¡Œ
t.detach();

// æ³¨æ„ï¼šå¿…é¡»è°ƒç”¨joinæˆ–detachï¼Œå¦åˆ™ç¨‹åºç»ˆæ­¢æ—¶ä¼šè°ƒç”¨std::terminate
```

#### ä½¿ç”¨vectorç®¡ç†å¤šä¸ªçº¿ç¨‹

```cpp
std::vector<std::thread> threads;

// åˆ›å»ºå¤šä¸ªçº¿ç¨‹
for (int i = 0; i < 10; i++) {
    threads.emplace_back([i]() {
        std::cout << "çº¿ç¨‹ " << i << std::endl;
    });
}

// ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
for (auto& t : threads) {
    t.join();
}
```

### 5.3 çº¿ç¨‹å®‰å…¨çš„è¾“å‡ºæŠ‘åˆ¶

**é—®é¢˜**ï¼šå¤šçº¿ç¨‹è¾“å‡ºä¼šå¯¼è‡´æµ‹è¯•ç»“æœæ··ä¹±

**è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨CoutRedirectç±»ä¸´æ—¶ç¦ç”¨è¾“å‡º

```cpp
// ç”¨äºä¸´æ—¶ç¦ç”¨coutè¾“å‡ºçš„å·¥å…·ç±»
class CoutRedirect {
private:
    std::streambuf* old_buf;
    std::ostringstream null_stream;
    
public:
    CoutRedirect() {
        old_buf = std::cout.rdbuf();
        std::cout.rdbuf(null_stream.rdbuf());
    }
    
    ~CoutRedirect() {
        std::cout.rdbuf(old_buf);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
void test_with_silent_output() {
    auto start = std::chrono::high_resolution_clock::now();
    
    {
        CoutRedirect redirect;  // ç¦ç”¨è¾“å‡º
        
        for (int i = 0; i < 10000; i++) {
            skipList.insert_element(i, "value");  // ä¸ä¼šè¾“å‡º
        }
        
    }  // redirectææ„ï¼Œæ¢å¤è¾“å‡º
    
    auto end = std::chrono::high_resolution_clock::now();
    std::cout << "æµ‹è¯•å®Œæˆ" << std::endl;  // æ­£å¸¸è¾“å‡º
}
```

---

## å…­ã€å¤šçº¿ç¨‹ç¼–ç¨‹æ ¸å¿ƒæ¦‚å¿µ

### 6.1 äº’æ–¥é”ï¼ˆMutexï¼‰

#### ä»€ä¹ˆæ˜¯äº’æ–¥é”ï¼Ÿ

äº’æ–¥é”ï¼ˆMutual Exclusionï¼‰æ˜¯ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºã€‚

```cpp
#include <mutex>

std::mutex mtx;
int shared_counter = 0;

void increment() {
    mtx.lock();      // ğŸ”’ åŠ é”
    shared_counter++;
    mtx.unlock();    // ğŸ”“ è§£é”
}
```

#### å·¥ä½œåŸç†

```
æ—¶é—´çº¿ï¼š
t1: çº¿ç¨‹Aè°ƒç”¨lock() â†’ è·å¾—é” âœ“
t2: çº¿ç¨‹Bè°ƒç”¨lock() â†’ ç­‰å¾…ï¼ˆçº¿ç¨‹AæŒæœ‰é”ï¼‰
t3: çº¿ç¨‹Aæ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
t4: çº¿ç¨‹Aè°ƒç”¨unlock() â†’ é‡Šæ”¾é”
t5: çº¿ç¨‹Bè·å¾—é” âœ“
t6: çº¿ç¨‹Bæ‰§è¡Œä¸´ç•ŒåŒºä»£ç 
t7: çº¿ç¨‹Bè°ƒç”¨unlock() â†’ é‡Šæ”¾é”
```

#### ä½¿ç”¨std::lock_guardï¼ˆæ¨èï¼‰

```cpp
void increment_safe() {
    std::lock_guard<std::mutex> lock(mtx);  // è‡ªåŠ¨åŠ é”
    shared_counter++;
    // å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨è§£é”ï¼ˆå³ä½¿å‘ç”Ÿå¼‚å¸¸ï¼‰
}
```

**ä¼˜åŠ¿**ï¼š
- RAIIåŸåˆ™ï¼ˆResource Acquisition Is Initializationï¼‰
- å¼‚å¸¸å®‰å…¨
- é¿å…å¿˜è®°è§£é”

#### ä½¿ç”¨std::unique_lockï¼ˆæ›´çµæ´»ï¼‰

```cpp
void flexible_lock() {
    std::unique_lock<std::mutex> lock(mtx);  // è‡ªåŠ¨åŠ é”
    
    // å¯ä»¥æ‰‹åŠ¨è§£é”
    lock.unlock();
    
    // æ‰§è¡Œä¸éœ€è¦é”çš„æ“ä½œ
    do_something();
    
    // å¯ä»¥é‡æ–°åŠ é”
    lock.lock();
    
    shared_counter++;
}  // ææ„æ—¶è‡ªåŠ¨è§£é”ï¼ˆå¦‚æœæŒæœ‰é”ï¼‰
```

### 6.2 æ­»é”ï¼ˆDeadlockï¼‰

#### ä»€ä¹ˆæ˜¯æ­»é”ï¼Ÿ

ä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹é‡Šæ”¾é”ï¼Œå¯¼è‡´æ‰€æœ‰çº¿ç¨‹éƒ½æ— æ³•ç»§ç»­æ‰§è¡Œã€‚

```cpp
std::mutex mtx1, mtx2;

// çº¿ç¨‹A
void thread_A() {
    mtx1.lock();  // è·å¾—é”1
    // ... 
    mtx2.lock();  // ç­‰å¾…é”2ï¼ˆçº¿ç¨‹BæŒæœ‰ï¼‰
    // æ­»é”ï¼
}

// çº¿ç¨‹B
void thread_B() {
    mtx2.lock();  // è·å¾—é”2
    // ...
    mtx1.lock();  // ç­‰å¾…é”1ï¼ˆçº¿ç¨‹AæŒæœ‰ï¼‰
    // æ­»é”ï¼
}
```

#### æ­»é”çš„å››ä¸ªå¿…è¦æ¡ä»¶

1. **äº’æ–¥æ¡ä»¶**ï¼šèµ„æºä¸èƒ½è¢«å…±äº«
2. **æŒæœ‰å¹¶ç­‰å¾…**ï¼šçº¿ç¨‹æŒæœ‰èµ„æºçš„åŒæ—¶ç­‰å¾…å…¶ä»–èµ„æº
3. **ä¸å¯å‰¥å¤º**ï¼šèµ„æºä¸èƒ½è¢«å¼ºåˆ¶é‡Šæ”¾
4. **å¾ªç¯ç­‰å¾…**ï¼šå­˜åœ¨çº¿ç¨‹ç­‰å¾…ç¯è·¯

#### é¿å…æ­»é”çš„æ–¹æ³•

**æ–¹æ³•1ï¼šæŒ‰å›ºå®šé¡ºåºè·å–é”**

```cpp
// æ€»æ˜¯å…ˆè·å–mtx1ï¼Œå†è·å–mtx2
void thread_safe() {
    std::lock_guard<std::mutex> lock1(mtx1);  // å…ˆé”1
    std::lock_guard<std::mutex> lock2(mtx2);  // å†é”2
    // æ‰§è¡Œæ“ä½œ
}
```

**æ–¹æ³•2ï¼šä½¿ç”¨std::lockåŒæ—¶è·å–å¤šä¸ªé”**

```cpp
void thread_safe_v2() {
    std::unique_lock<std::mutex> lock1(mtx1, std::defer_lock);
    std::unique_lock<std::mutex> lock2(mtx2, std::defer_lock);
    
    std::lock(lock1, lock2);  // åŸå­åœ°è·å–ä¸¤ä¸ªé”
    
    // æ‰§è¡Œæ“ä½œ
}
```

**æ–¹æ³•3ï¼šä½¿ç”¨è¶…æ—¶æœºåˆ¶**

```cpp
void thread_safe_v3() {
    std::unique_lock<std::mutex> lock1(mtx1);
    
    if (mtx2.try_lock_for(std::chrono::milliseconds(100))) {
        // æˆåŠŸè·å–é”2
        // æ‰§è¡Œæ“ä½œ
        mtx2.unlock();
    } else {
        // è¶…æ—¶ï¼Œæ”¾å¼ƒæ“ä½œ
    }
}
```

### 6.3 ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰

#### ä»€ä¹ˆæ˜¯ç«æ€æ¡ä»¶ï¼Ÿ

å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ®ï¼Œç»“æœå–å†³äºæ‰§è¡Œé¡ºåºï¼Œå¯¼è‡´ä¸å¯é¢„æµ‹çš„è¡Œä¸ºã€‚

```cpp
int counter = 0;

// çº¿ç¨‹Aå’Œçº¿ç¨‹BåŒæ—¶æ‰§è¡Œ
void increment() {
    counter++;  // ä¸æ˜¯åŸå­æ“ä½œï¼
}

// å®é™…æ‰§è¡Œï¼š
// 1. è¯»å–counterçš„å€¼ï¼ˆå‡è®¾ä¸º0ï¼‰
// 2. åŠ 1
// 3. å†™å›counter

// ç«æ€æ¡ä»¶ï¼š
// æ—¶åˆ»1: çº¿ç¨‹Aè¯»å–counter=0
// æ—¶åˆ»2: çº¿ç¨‹Bè¯»å–counter=0
// æ—¶åˆ»3: çº¿ç¨‹Aå†™å…¥counter=1
// æ—¶åˆ»4: çº¿ç¨‹Bå†™å…¥counter=1
// ç»“æœï¼šcounter=1ï¼ˆé¢„æœŸä¸º2ï¼‰
```

#### è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨äº’æ–¥é”

```cpp
std::mutex mtx;
int counter = 0;

void increment_safe() {
    std::lock_guard<std::mutex> lock(mtx);
    counter++;  // ç°åœ¨æ˜¯çº¿ç¨‹å®‰å…¨çš„
}
```

### 6.4 åŸå­æ“ä½œï¼ˆAtomic Operationsï¼‰

#### ä½¿ç”¨std::atomic

```cpp
#include <atomic>

std::atomic<int> counter(0);

void increment_atomic() {
    counter++;  // åŸå­æ“ä½œï¼Œä¸éœ€è¦é”
}

void decrement_atomic() {
    counter--;  // åŸå­æ“ä½œ
}

int get_value() {
    return counter.load();  // åŸå­è¯»å–
}
```

**ä¼˜åŠ¿**ï¼š
- æ— é”ï¼ˆlock-freeï¼‰
- æ€§èƒ½æ›´å¥½
- é€‚ç”¨äºç®€å•çš„è®¡æ•°å™¨ã€æ ‡å¿—ä½

**é™åˆ¶**ï¼š
- åªé€‚ç”¨äºç®€å•ç±»å‹
- å¤æ‚æ“ä½œä»éœ€è¦é”

### 6.5 è¯»å†™é”ï¼ˆShared Mutexï¼‰

#### ä»€ä¹ˆæ˜¯è¯»å†™é”ï¼Ÿ

å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»ï¼Œä½†å†™æ“ä½œç‹¬å ã€‚

```cpp
#include <shared_mutex>

std::shared_mutex rw_mtx;
int shared_data = 0;

// è¯»æ“ä½œï¼ˆå…±äº«é”ï¼‰
void read_data() {
    std::shared_lock<std::shared_mutex> lock(rw_mtx);
    std::cout << "æ•°æ®: " << shared_data << std::endl;
    // å¤šä¸ªè¯»çº¿ç¨‹å¯ä»¥åŒæ—¶æ‰§è¡Œ
}

// å†™æ“ä½œï¼ˆç‹¬å é”ï¼‰
void write_data(int value) {
    std::unique_lock<std::shared_mutex> lock(rw_mtx);
    shared_data = value;
    // å†™æ“ä½œç‹¬å ï¼Œå…¶ä»–è¯»å†™æ“ä½œéƒ½è¦ç­‰å¾…
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- è¯»å¤šå†™å°‘çš„åœºæ™¯
- å¯ä»¥æ˜¾è‘—æå‡å¹¶å‘æ€§èƒ½

---

## ä¸ƒã€å®æˆ˜æ¡ˆä¾‹ä¸æœ€ä½³å®è·µ

### 7.1 æ¡ˆä¾‹1ï¼šå¤šçº¿ç¨‹æ’å…¥æµ‹è¯•

```cpp
#include <thread>
#include <vector>
#include <chrono>
#include "skiplist_optimized.h"

void benchmark_concurrent_insert() {
    const int NUM_THREADS = 8;
    const int OPS_PER_THREAD = 10000;
    
    SkipListOptimized<int, std::string> skipList(18, 16);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // åˆ›å»ºçº¿ç¨‹
    std::vector<std::thread> threads;
    for (int i = 0; i < NUM_THREADS; i++) {
        threads.emplace_back([&skipList, i, OPS_PER_THREAD]() {
            for (int j = 0; j < OPS_PER_THREAD; j++) {
                int key = i * OPS_PER_THREAD + j;
                skipList.insert_element(key, "value");
            }
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    int total_ops = NUM_THREADS * OPS_PER_THREAD;
    std::cout << "æ€»æ“ä½œæ•°: " << total_ops << std::endl;
    std::cout << "æ€»è€—æ—¶: " << duration.count() << " ms" << std::endl;
    std::cout << "QPS: " << (total_ops * 1000.0 / duration.count()) << std::endl;
    std::cout << "æœ€ç»ˆå…ƒç´ æ•°é‡: " << skipList.size() << std::endl;
}
```

### 7.2 æ¡ˆä¾‹2ï¼šæ··åˆè¯»å†™æµ‹è¯•

```cpp
void benchmark_mixed_operations() {
    const int NUM_READERS = 4;
    const int NUM_WRITERS = 4;
    const int OPS_PER_THREAD = 5000;
    
    SkipListOptimized<int, std::string> skipList(18, 16);
    
    // å…ˆæ’å…¥ä¸€äº›æ•°æ®
    for (int i = 0; i < 10000; i++) {
        skipList.insert_element(i, "value");
    }
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<std::thread> threads;
    
    // åˆ›å»ºè¯»çº¿ç¨‹
    for (int i = 0; i < NUM_READERS; i++) {
        threads.emplace_back([&skipList, OPS_PER_THREAD]() {
            for (int j = 0; j < OPS_PER_THREAD; j++) {
                skipList.search_element_silent(rand() % 10000);
            }
        });
    }
    
    // åˆ›å»ºå†™çº¿ç¨‹
    for (int i = 0; i < NUM_WRITERS; i++) {
        threads.emplace_back([&skipList, i, OPS_PER_THREAD]() {
            for (int j = 0; j < OPS_PER_THREAD; j++) {
                int key = 10000 + i * OPS_PER_THREAD + j;
                skipList.insert_element(key, "value");
            }
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& t : threads) {
        t.join();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    int total_ops = (NUM_READERS + NUM_WRITERS) * OPS_PER_THREAD;
    std::cout << "æ··åˆæ“ä½œQPS: " << (total_ops * 1000.0 / duration.count()) << std::endl;
}
```

### 7.3 æœ€ä½³å®è·µæ€»ç»“

#### 1. é”çš„ä½¿ç”¨åŸåˆ™

âœ… **æ¨èåšæ³•**ï¼š
```cpp
// ä½¿ç”¨RAIIç®¡ç†é”
void good_practice() {
    std::lock_guard<std::mutex> lock(mtx);
    // ä¸´ç•ŒåŒºä»£ç 
}  // è‡ªåŠ¨è§£é”
```

âŒ **ä¸æ¨èåšæ³•**ï¼š
```cpp
// æ‰‹åŠ¨ç®¡ç†é”ï¼Œå®¹æ˜“å‡ºé”™
void bad_practice() {
    mtx.lock();
    // ä¸´ç•ŒåŒºä»£ç 
    // å¦‚æœè¿™é‡ŒæŠ›å‡ºå¼‚å¸¸ï¼Œé”æ°¸è¿œä¸ä¼šé‡Šæ”¾ï¼
    mtx.unlock();
}
```

#### 2. å‡å°‘é”çš„æŒæœ‰æ—¶é—´

âœ… **æ¨èåšæ³•**ï¼š
```cpp
void good_practice() {
    // å‡†å¤‡æ•°æ®ï¼ˆä¸éœ€è¦é”ï¼‰
    std::string data = prepare_data();
    
    {
        std::lock_guard<std::mutex> lock(mtx);
        // åªåœ¨å¿…è¦æ—¶æŒæœ‰é”
        shared_data = data;
    }  // å°½å¿«é‡Šæ”¾é”
    
    // åç»­å¤„ç†ï¼ˆä¸éœ€è¦é”ï¼‰
    process_result();
}
```

âŒ **ä¸æ¨èåšæ³•**ï¼š
```cpp
void bad_practice() {
    std::lock_guard<std::mutex> lock(mtx);
    
    // åœ¨é”å†…åšè€—æ—¶æ“ä½œ
    std::string data = prepare_data();  // æ…¢
    shared_data = data;
    process_result();  // æ…¢
}  // é”æŒæœ‰æ—¶é—´è¿‡é•¿
```

#### 3. é¿å…åµŒå¥—é”

âœ… **æ¨èåšæ³•**ï¼š
```cpp
// æŒ‰å›ºå®šé¡ºåºè·å–é”
void good_practice() {
    std::lock_guard<std::mutex> lock1(mtx1);
    std::lock_guard<std::mutex> lock2(mtx2);
    // æ“ä½œ
}
```

âŒ **ä¸æ¨èåšæ³•**ï¼š
```cpp
// ä¸åŒå‡½æ•°ä»¥ä¸åŒé¡ºåºè·å–é”
void bad_practice_A() {
    std::lock_guard<std::mutex> lock1(mtx1);
    std::lock_guard<std::mutex> lock2(mtx2);
}

void bad_practice_B() {
    std::lock_guard<std::mutex> lock2(mtx2);  // é¡ºåºä¸åŒ
    std::lock_guard<std::mutex> lock1(mtx1);  // å¯èƒ½æ­»é”
}
```

#### 4. é€‰æ‹©åˆé€‚çš„åŒæ­¥æœºåˆ¶

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ |
|------|---------|
| ç®€å•è®¡æ•°å™¨ | `std::atomic` |
| è¯»å¤šå†™å°‘ | `std::shared_mutex` |
| å¤æ‚æ•°æ®ç»“æ„ | `std::mutex` + ç»†ç²’åº¦é” |
| ç”Ÿäº§è€…-æ¶ˆè´¹è€… | `std::condition_variable` |

#### 5. æ€§èƒ½æµ‹è¯•è¦ç‚¹

```cpp
// 1. ç¦ç”¨è¾“å‡ºï¼ˆè¾“å‡ºä¼šä¸¥é‡å½±å“æ€§èƒ½ï¼‰
{
    CoutRedirect redirect;
    // æ‰§è¡Œæµ‹è¯•
}

// 2. ä½¿ç”¨é«˜ç²¾åº¦è®¡æ—¶å™¨
auto start = std::chrono::high_resolution_clock::now();
// æ‰§è¡Œæ“ä½œ
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

// 3. æµ‹è¯•è¶³å¤Ÿçš„æ•°æ®é‡ï¼ˆè‡³å°‘10000+ï¼‰
const int TEST_COUNT = 100000;

// 4. å¤šæ¬¡æµ‹è¯•å–å¹³å‡å€¼
for (int i = 0; i < 5; i++) {
    run_benchmark();
}
```

---

## å…«ã€å¸¸è§é—®é¢˜ä¸è°ƒè¯•

### 8.1 å¸¸è§é—®é¢˜

#### Q1: ä¸ºä»€ä¹ˆå¤šçº¿ç¨‹æ€§èƒ½åè€Œä¸‹é™ï¼Ÿ

**å¯èƒ½åŸå› **ï¼š
1. é”ç«äº‰è¿‡äºæ¿€çƒˆ
2. çº¿ç¨‹æ•°è¶…è¿‡CPUæ ¸å¿ƒæ•°
3. æµ‹è¯•æ•°æ®é‡å¤ªå°
4. é¢‘ç¹çš„çº¿ç¨‹åˆ›å»ºé”€æ¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ä½¿ç”¨ç»†ç²’åº¦é”
- çº¿ç¨‹æ•°è®¾ç½®ä¸ºCPUæ ¸å¿ƒæ•°çš„2-4å€
- å¢åŠ æµ‹è¯•æ•°æ®é‡
- ä½¿ç”¨çº¿ç¨‹æ± 

#### Q2: ç¨‹åºå¶å°”å´©æºƒï¼Œéš¾ä»¥å¤ç°

**å¯èƒ½åŸå› **ï¼šç«æ€æ¡ä»¶

**è°ƒè¯•æ–¹æ³•**ï¼š
```bash
# ä½¿ç”¨ThreadSanitizeræ£€æµ‹æ•°æ®ç«äº‰
g++ -fsanitize=thread -g -o test test.cpp
./test
```

#### Q3: ç¨‹åºå¡æ­»ä¸åŠ¨

**å¯èƒ½åŸå› **ï¼šæ­»é”

**è°ƒè¯•æ–¹æ³•**ï¼š
```bash
# ä½¿ç”¨gdbæŸ¥çœ‹çº¿ç¨‹çŠ¶æ€
gdb ./test
(gdb) run
# ç¨‹åºå¡æ­»åæŒ‰Ctrl+C
(gdb) info threads
(gdb) thread apply all bt
```

### 8.2 è°ƒè¯•å·¥å…·

#### Valgrind - å†…å­˜æ£€æŸ¥

```bash
# æ£€æŸ¥å†…å­˜æ³„æ¼
valgrind --leak-check=full ./test

# æ£€æŸ¥çº¿ç¨‹é”™è¯¯
valgrind --tool=helgrind ./test
```

#### GDB - è°ƒè¯•å™¨

```bash
# å¯åŠ¨è°ƒè¯•
gdb ./test

# å¸¸ç”¨å‘½ä»¤
(gdb) break main          # è®¾ç½®æ–­ç‚¹
(gdb) run                 # è¿è¡Œç¨‹åº
(gdb) info threads        # æŸ¥çœ‹æ‰€æœ‰çº¿ç¨‹
(gdb) thread 2            # åˆ‡æ¢åˆ°çº¿ç¨‹2
(gdb) bt                  # æŸ¥çœ‹è°ƒç”¨æ ˆ
(gdb) print variable      # æ‰“å°å˜é‡å€¼
```

---

## ä¹ã€æ€»ç»“

### 9.1 é¡¹ç›®å¤šçº¿ç¨‹æŠ€æœ¯æ€»ç»“

æœ¬é¡¹ç›®ä½¿ç”¨äº†ä»¥ä¸‹å¤šçº¿ç¨‹æŠ€æœ¯ï¼š

1. **åŸç‰ˆè·³è¡¨**ï¼š
   - å…¨å±€äº’æ–¥é”ï¼ˆ`std::mutex`ï¼‰
   - ç®€å•ä½†æ€§èƒ½æœ‰é™

2. **ä¼˜åŒ–ç‰ˆè·³è¡¨**ï¼š
   - åˆ†æ®µé”æœºåˆ¶ï¼ˆ16ä¸ªæ®µï¼‰
   - å¤šå±‚é”ä¿æŠ¤ä¸åŒæ•°æ®
   - æ˜¾è‘—æå‡å¹¶å‘æ€§èƒ½

3. **å†…å­˜æ± **ï¼š
   - äº’æ–¥é”ä¿æŠ¤ç©ºé—²åˆ—è¡¨
   - çº¿ç¨‹å®‰å…¨çš„å†…å­˜åˆ†é…

4. **æµ‹è¯•ç¨‹åº**ï¼š
   - `std::thread` è¿›è¡Œæ€§èƒ½æµ‹è¯•
   - `pthread` è¿›è¡Œå‹åŠ›æµ‹è¯•

### 9.2 å…³é”®æ”¶è·

é€šè¿‡æœ¬æ–‡æ¡£ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š

âœ… äº’æ–¥é”çš„ä½¿ç”¨ï¼ˆ`std::mutex`ï¼‰  
âœ… RAIIé”ç®¡ç†ï¼ˆ`std::lock_guard`, `std::unique_lock`ï¼‰  
âœ… çº¿ç¨‹åˆ›å»ºä¸ç®¡ç†ï¼ˆ`std::thread`, `pthread`ï¼‰  
âœ… æ­»é”çš„åŸå› ä¸é¢„é˜²  
âœ… ç«æ€æ¡ä»¶çš„è¯†åˆ«ä¸è§£å†³  
âœ… ç»†ç²’åº¦é”çš„è®¾è®¡æ€æƒ³  
âœ… å¤šçº¿ç¨‹æ€§èƒ½æµ‹è¯•æ–¹æ³•  
âœ… è°ƒè¯•å·¥å…·çš„ä½¿ç”¨  

### 9.3 è¿›é˜¶å­¦ä¹ æ–¹å‘

1. **æ— é”ç¼–ç¨‹**ï¼š
   - `std::atomic`
   - Lock-freeæ•°æ®ç»“æ„
   - CASï¼ˆCompare-And-Swapï¼‰

2. **è¯»å†™é”**ï¼š
   - `std::shared_mutex`
   - è¯»å¤šå†™å°‘åœºæ™¯ä¼˜åŒ–

3. **æ¡ä»¶å˜é‡**ï¼š
   - `std::condition_variable`
   - ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

4. **çº¿ç¨‹æ± **ï¼š
   - é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹
   - ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†

5. **å¹¶å‘å®¹å™¨**ï¼š
   - `std::concurrent_queue`
   - `tbb::concurrent_hash_map`

---

## åã€å‚è€ƒèµ„æº

### ä¹¦ç±æ¨è

1. **ã€ŠC++å¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹** - Anthony Williams
2. **ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹** - CSAPP
3. **ã€ŠUnixç¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹** - APUE

### åœ¨çº¿èµ„æº

- [cppreference.com - çº¿ç¨‹æ”¯æŒåº“](https://zh.cppreference.com/w/cpp/thread)
- [pthreadæ–‡æ¡£](https://man7.org/linux/man-pages/man7/pthreads.7.html)
- [C++å¹¶å‘ç¼–ç¨‹æŒ‡å—](https://paul.pub/cpp-concurrency/)

### å·¥å…·

- [ThreadSanitizer](https://github.com/google/sanitizers)
- [Valgrind](https://valgrind.org/)
- [GDB](https://www.gnu.org/software/gdb/)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2026å¹´2æœˆ11æ—¥  
**ä½œè€…**ï¼šåŸºäºSkiplist-CPPé¡¹ç›®æ•´ç†

