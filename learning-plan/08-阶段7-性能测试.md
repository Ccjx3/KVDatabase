# é˜¶æ®µ 7ï¼šæ€§èƒ½æµ‹è¯•ä¸ä¼˜åŒ– ğŸ“Š

## å­¦ä¹ ç›®æ ‡
- è¿›è¡Œå¤§è§„æ¨¡æ€§èƒ½æµ‹è¯•
- è®¡ç®— QPSï¼ˆæ¯ç§’æŸ¥è¯¢æ•°ï¼‰
- åˆ†ææ—¶é—´å¤æ‚åº¦
- ç†è§£è·³è¡¨çš„æ€§èƒ½ç‰¹ç‚¹

---

## 1. æ€§èƒ½æŒ‡æ ‡

### ä¸»è¦æŒ‡æ ‡

1. **QPSï¼ˆQueries Per Secondï¼‰**ï¼šæ¯ç§’å¤„ç†çš„è¯·æ±‚æ•°
2. **å»¶è¿Ÿï¼ˆLatencyï¼‰**ï¼šå•æ¬¡æ“ä½œçš„è€—æ—¶
3. **ååé‡ï¼ˆThroughputï¼‰**ï¼šå•ä½æ—¶é—´å†…å¤„ç†çš„æ•°æ®é‡

### æµ‹è¯•åœºæ™¯

- **æ’å…¥æ€§èƒ½**ï¼šéšæœºæ’å…¥å¤§é‡æ•°æ®
- **æŸ¥æ‰¾æ€§èƒ½**ï¼šéšæœºæŸ¥æ‰¾å·²å­˜åœ¨çš„æ•°æ®
- **æ··åˆæ€§èƒ½**ï¼šæ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤æ··åˆæ“ä½œ

---

## 2. æ€§èƒ½æµ‹è¯•ä»£ç 

**æ–‡ä»¶å**ï¼š`stage7_benchmark.cpp`

```cpp
#include <iostream>
#include <chrono>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>
using namespace std;

// ç®€åŒ–çš„è·³è¡¨å®ç°ï¼ˆç”¨äºæ€§èƒ½æµ‹è¯•ï¼‰
template<typename K, typename V>
class Node {
public:
    K key;
    V value;
    Node<K, V>** forward;
    int node_level;
    
    Node(K k, V v, int level) {
        key = k;
        value = v;
        node_level = level;
        forward = new Node<K, V>*[level + 1];
        for (int i = 0; i <= level; i++) {
            forward[i] = nullptr;
        }
    }
    
    ~Node() {
        delete[] forward;
    }
};

template<typename K, typename V>
class SkipList {
private:
    int max_level;
    int current_level;
    Node<K, V>* header;
    int element_count;
    
public:
    SkipList(int max_lvl) : max_level(max_lvl), current_level(0), element_count(0) {
        K k;
        V v;
        header = new Node<K, V>(k, v, max_level);
    }
    
    ~SkipList() {
        Node<K, V>* current = header->forward[0];
        while (current != nullptr) {
            Node<K, V>* temp = current;
            current = current->forward[0];
            delete temp;
        }
        delete header;
    }
    
    int get_random_level() {
        int level = 0;
        while (rand() % 2 && level < max_level) {
            level++;
        }
        return level;
    }
    
    void insert(K key, V value) {
        Node<K, V>* current = header;
        Node<K, V>* update[max_level + 1];
        
        for (int i = 0; i <= max_level; i++) {
            update[i] = nullptr;
        }
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
            update[i] = current;
        }
        
        current = current->forward[0];
        
        if (current != nullptr && current->key == key) {
            return;
        }
        
        int random_level = get_random_level();
        
        if (random_level > current_level) {
            for (int i = current_level + 1; i <= random_level; i++) {
                update[i] = header;
            }
            current_level = random_level;
        }
        
        Node<K, V>* new_node = new Node<K, V>(key, value, random_level);
        
        for (int i = 0; i <= random_level; i++) {
            new_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = new_node;
        }
        
        element_count++;
    }
    
    bool search(K key) {
        Node<K, V>* current = header;
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
        }
        
        current = current->forward[0];
        return (current != nullptr && current->key == key);
    }
    
    int size() {
        return element_count;
    }
};

// æ€§èƒ½æµ‹è¯•å‡½æ•°
void benchmark_insert(int num_elements) {
    cout << "\n========================================" << endl;
    cout << "  æ’å…¥æ€§èƒ½æµ‹è¯•" << endl;
    cout << "========================================" << endl;
    cout << "æµ‹è¯•è§„æ¨¡: " << num_elements << " ä¸ªå…ƒç´ " << endl;
    
    SkipList<int, string> skipList(18);
    
    // ç”Ÿæˆéšæœºæ•°æ®
    vector<int> keys;
    for (int i = 0; i < num_elements; i++) {
        keys.push_back(i);
    }
    random_shuffle(keys.begin(), keys.end());
    
    // å¼€å§‹è®¡æ—¶
    auto start = chrono::high_resolution_clock::now();
    
    // æ’å…¥æ•°æ®
    for (int key : keys) {
        skipList.insert(key, "value");
    }
    
    // ç»“æŸè®¡æ—¶
    auto finish = chrono::high_resolution_clock::now();
    chrono::duration<double> elapsed = finish - start;
    
    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    double seconds = elapsed.count();
    double qps = num_elements / seconds;
    double avg_latency_us = (seconds * 1000000) / num_elements;
    
    cout << "\nã€ç»“æœã€‘" << endl;
    cout << "æ€»è€—æ—¶: " << seconds << " ç§’" << endl;
    cout << "QPS: " << qps << " æ¬¡/ç§’" << endl;
    cout << "å¹³å‡å»¶è¿Ÿ: " << avg_latency_us << " å¾®ç§’" << endl;
    cout << "å®é™…æ’å…¥: " << skipList.size() << " ä¸ªå…ƒç´ " << endl;
}

void benchmark_search(int num_elements, int num_searches) {
    cout << "\n========================================" << endl;
    cout << "  æŸ¥æ‰¾æ€§èƒ½æµ‹è¯•" << endl;
    cout << "========================================" << endl;
    cout << "æ•°æ®è§„æ¨¡: " << num_elements << " ä¸ªå…ƒç´ " << endl;
    cout << "æŸ¥æ‰¾æ¬¡æ•°: " << num_searches << " æ¬¡" << endl;
    
    SkipList<int, string> skipList(18);
    
    // å…ˆæ’å…¥æ•°æ®
    cout << "\nå‡†å¤‡æ•°æ®..." << endl;
    for (int i = 0; i < num_elements; i++) {
        skipList.insert(i, "value");
    }
    cout << "æ•°æ®å‡†å¤‡å®Œæˆ" << endl;
    
    // ç”ŸæˆéšæœºæŸ¥æ‰¾åºåˆ—
    vector<int> search_keys;
    for (int i = 0; i < num_searches; i++) {
        search_keys.push_back(rand() % num_elements);
    }
    
    // å¼€å§‹è®¡æ—¶
    auto start = chrono::high_resolution_clock::now();
    
    // æŸ¥æ‰¾æ•°æ®
    int found_count = 0;
    for (int key : search_keys) {
        if (skipList.search(key)) {
            found_count++;
        }
    }
    
    // ç»“æŸè®¡æ—¶
    auto finish = chrono::high_resolution_clock::now();
    chrono::duration<double> elapsed = finish - start;
    
    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    double seconds = elapsed.count();
    double qps = num_searches / seconds;
    double avg_latency_us = (seconds * 1000000) / num_searches;
    
    cout << "\nã€ç»“æœã€‘" << endl;
    cout << "æ€»è€—æ—¶: " << seconds << " ç§’" << endl;
    cout << "QPS: " << qps << " æ¬¡/ç§’" << endl;
    cout << "å¹³å‡å»¶è¿Ÿ: " << avg_latency_us << " å¾®ç§’" << endl;
    cout << "æ‰¾åˆ°: " << found_count << " / " << num_searches << endl;
}

void benchmark_mixed(int num_operations) {
    cout << "\n========================================" << endl;
    cout << "  æ··åˆæ“ä½œæ€§èƒ½æµ‹è¯•" << endl;
    cout << "========================================" << endl;
    cout << "æ“ä½œæ¬¡æ•°: " << num_operations << " æ¬¡" << endl;
    cout << "æ“ä½œæ¯”ä¾‹: 50% æ’å…¥, 50% æŸ¥æ‰¾" << endl;
    
    SkipList<int, string> skipList(18);
    
    // å¼€å§‹è®¡æ—¶
    auto start = chrono::high_resolution_clock::now();
    
    int insert_count = 0;
    int search_count = 0;
    
    for (int i = 0; i < num_operations; i++) {
        if (rand() % 2 == 0) {
            // æ’å…¥æ“ä½œ
            skipList.insert(rand() % num_operations, "value");
            insert_count++;
        } else {
            // æŸ¥æ‰¾æ“ä½œ
            skipList.search(rand() % num_operations);
            search_count++;
        }
    }
    
    // ç»“æŸè®¡æ—¶
    auto finish = chrono::high_resolution_clock::now();
    chrono::duration<double> elapsed = finish - start;
    
    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    double seconds = elapsed.count();
    double qps = num_operations / seconds;
    
    cout << "\nã€ç»“æœã€‘" << endl;
    cout << "æ€»è€—æ—¶: " << seconds << " ç§’" << endl;
    cout << "æ€» QPS: " << qps << " æ¬¡/ç§’" << endl;
    cout << "æ’å…¥æ¬¡æ•°: " << insert_count << endl;
    cout << "æŸ¥æ‰¾æ¬¡æ•°: " << search_count << endl;
    cout << "æœ€ç»ˆå¤§å°: " << skipList.size() << endl;
}

// ä¸åŒè§„æ¨¡çš„æ€§èƒ½å¯¹æ¯”
void benchmark_scalability() {
    cout << "\n========================================" << endl;
    cout << "  å¯æ‰©å±•æ€§æµ‹è¯•" << endl;
    cout << "========================================" << endl;
    
    vector<int> sizes = {1000, 10000, 100000, 1000000};
    
    cout << "\nè§„æ¨¡\t\tæ’å…¥è€—æ—¶(ç§’)\tæŸ¥æ‰¾è€—æ—¶(ç§’)" << endl;
    cout << "------------------------------------------------" << endl;
    
    for (int size : sizes) {
        SkipList<int, string> skipList(18);
        
        // æµ‹è¯•æ’å…¥
        auto start = chrono::high_resolution_clock::now();
        for (int i = 0; i < size; i++) {
            skipList.insert(i, "value");
        }
        auto finish = chrono::high_resolution_clock::now();
        double insert_time = chrono::duration<double>(finish - start).count();
        
        // æµ‹è¯•æŸ¥æ‰¾
        start = chrono::high_resolution_clock::now();
        for (int i = 0; i < size; i++) {
            skipList.search(i);
        }
        finish = chrono::high_resolution_clock::now();
        double search_time = chrono::duration<double>(finish - start).count();
        
        cout << size << "\t\t" << insert_time << "\t\t" << search_time << endl;
    }
}

int main() {
    srand(time(nullptr));
    
    cout << "========================================" << endl;
    cout << "  é˜¶æ®µ7ï¼šè·³è¡¨æ€§èƒ½æµ‹è¯•" << endl;
    cout << "========================================\n" << endl;
    
    // æµ‹è¯•1ï¼šæ’å…¥æ€§èƒ½
    benchmark_insert(100000);
    
    // æµ‹è¯•2ï¼šæŸ¥æ‰¾æ€§èƒ½
    benchmark_search(100000, 100000);
    
    // æµ‹è¯•3ï¼šæ··åˆæ“ä½œ
    benchmark_mixed(100000);
    
    // æµ‹è¯•4ï¼šå¯æ‰©å±•æ€§
    benchmark_scalability();
    
    cout << "\n========================================" << endl;
    cout << "  æ‰€æœ‰æµ‹è¯•å®Œæˆ" << endl;
    cout << "========================================" << endl;
    
    return 0;
}
```

---

## 3. ç¼–è¯‘å’Œè¿è¡Œ

### ç¼–è¯‘

```bash
cd /Users/cjx/Downloads/Skiplist-CPP-master/learning-plan
g++ -std=c++11 -O2 -o stage7 stage7_benchmark.cpp
```

**æ³¨æ„**ï¼šä½¿ç”¨ `-O2` ä¼˜åŒ–é€‰é¡¹ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚

### è¿è¡Œ

```bash
./stage7
```

---

## 4. é¢„æœŸç»“æœåˆ†æ

### å…¸å‹æ€§èƒ½æ•°æ®

åŸºäºåŸé¡¹ç›®çš„æµ‹è¯•ç»“æœï¼š

| æ“ä½œ | æ•°æ®è§„æ¨¡ | QPS | è¯´æ˜ |
|------|---------|-----|------|
| æ’å…¥ | 100 ä¸‡ | 24.39 ä¸‡/ç§’ | éšæœºæ’å…¥ |
| æŸ¥æ‰¾ | 100 ä¸‡ | 18.41 ä¸‡/ç§’ | éšæœºæŸ¥æ‰¾ |

### æ—¶é—´å¤æ‚åº¦éªŒè¯

ç†è®ºä¸Šï¼Œè·³è¡¨çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(log n)ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡æµ‹è¯•éªŒè¯ï¼š

```
æ•°æ®è§„æ¨¡    æ’å…¥æ—¶é—´    æŸ¥æ‰¾æ—¶é—´
1,000      0.01ç§’      0.01ç§’
10,000     0.12ç§’      0.10ç§’    (çº¦ 10 å€)
100,000    1.50ç§’      1.20ç§’    (çº¦ 10 å€)
1,000,000  18.00ç§’     15.00ç§’   (çº¦ 10 å€)

è§„å¾‹ï¼šæ•°æ®è§„æ¨¡å¢åŠ  10 å€ï¼Œæ—¶é—´ä¹Ÿå¢åŠ çº¦ 10 å€
è¿™ç¬¦åˆ O(log n) çš„ç‰¹æ€§
```

---

## 5. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 5.1 å†…å­˜æ± 

é¢‘ç¹çš„ `new` å’Œ `delete` ä¼šå½±å“æ€§èƒ½ï¼Œå¯ä»¥ä½¿ç”¨å†…å­˜æ± ï¼š

```cpp
class MemoryPool {
    vector<Node<K, V>*> pool;
    
public:
    Node<K, V>* allocate(K k, V v, int level) {
        if (pool.empty()) {
            return new Node<K, V>(k, v, level);
        } else {
            Node<K, V>* node = pool.back();
            pool.pop_back();
            // é‡æ–°åˆå§‹åŒ–èŠ‚ç‚¹
            return node;
        }
    }
    
    void deallocate(Node<K, V>* node) {
        pool.push_back(node);
    }
};
```

### 5.2 å‡å°‘é”ç«äº‰

ä½¿ç”¨ç»†ç²’åº¦é”æˆ–è¯»å†™é”ï¼š

```cpp
// ä¸ºæ¯ä¸€å±‚ä½¿ç”¨å•ç‹¬çš„é”
mutex level_locks[MAX_LEVEL];

void insert(K key, V value) {
    // åªé”å®šéœ€è¦ä¿®æ”¹çš„å±‚
    for (int i = 0; i <= random_level; i++) {
        lock_guard<mutex> lock(level_locks[i]);
        // æ’å…¥åˆ°ç¬¬ i å±‚
    }
}
```

### 5.3 é¢„åˆ†é…ç©ºé—´

å¦‚æœçŸ¥é“æ•°æ®è§„æ¨¡ï¼Œå¯ä»¥é¢„åˆ†é…ç©ºé—´ï¼š

```cpp
SkipList(int max_lvl, int expected_size) {
    // é¢„ç•™ç©ºé—´ï¼Œå‡å°‘å†…å­˜åˆ†é…æ¬¡æ•°
    // ...
}
```

---

## 6. ä¸å…¶ä»–æ•°æ®ç»“æ„å¯¹æ¯”

### æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

| æ•°æ®ç»“æ„ | æ’å…¥ | æŸ¥æ‰¾ | åˆ é™¤ | ç©ºé—´å¤æ‚åº¦ |
|---------|------|------|------|-----------|
| æ•°ç»„ï¼ˆæœ‰åºï¼‰ | O(n) | O(log n) | O(n) | O(n) |
| é“¾è¡¨ï¼ˆæœ‰åºï¼‰ | O(n) | O(n) | O(n) | O(n) |
| äºŒå‰æœç´¢æ ‘ | O(log n) | O(log n) | O(log n) | O(n) |
| çº¢é»‘æ ‘ | O(log n) | O(log n) | O(log n) | O(n) |
| **è·³è¡¨** | **O(log n)** | **O(log n)** | **O(log n)** | **O(n)** |
| å“ˆå¸Œè¡¨ | O(1) | O(1) | O(1) | O(n) |

### è·³è¡¨çš„ä¼˜åŠ¿

1. **å®ç°ç®€å•**ï¼šæ¯”çº¢é»‘æ ‘ç®€å•å¾—å¤š
2. **æ”¯æŒèŒƒå›´æŸ¥è¯¢**ï¼šå¯ä»¥é«˜æ•ˆéå†ä¸€ä¸ªèŒƒå›´å†…çš„å…ƒç´ 
3. **å¹¶å‘å‹å¥½**ï¼šæ¯”æ ‘ç»“æ„æ›´å®¹æ˜“å®ç°æ— é”ç‰ˆæœ¬
4. **ç©ºé—´å±€éƒ¨æ€§å¥½**ï¼šç¼“å­˜å‹å¥½

### è·³è¡¨çš„åŠ£åŠ¿

1. **ç©ºé—´å¼€é”€**ï¼šéœ€è¦é¢å¤–çš„æŒ‡é’ˆå­˜å‚¨ç´¢å¼•
2. **éšæœºæ€§**ï¼šæ€§èƒ½ä¾èµ–éšæœºæ•°è´¨é‡
3. **ä¸å¦‚å“ˆå¸Œè¡¨å¿«**ï¼šå¯¹äºå•ç‚¹æŸ¥è¯¢ï¼Œå“ˆå¸Œè¡¨æ›´å¿«

---

## 7. ç»ƒä¹ é¢˜

### ç»ƒä¹  1ï¼šæ€§èƒ½åˆ†æ
è¿è¡Œæ€§èƒ½æµ‹è¯•ï¼Œè®°å½•ç»“æœï¼Œåˆ†æç“¶é¢ˆåœ¨å“ªé‡Œã€‚

### ç»ƒä¹  2ï¼šä¼˜åŒ–å®ç°
å°è¯•å®ç°å†…å­˜æ± ï¼Œæµ‹è¯•æ€§èƒ½æå‡ã€‚

### ç»ƒä¹  3ï¼šå¯¹æ¯”æµ‹è¯•
å®ç°ä¸€ä¸ªç®€å•çš„äºŒå‰æœç´¢æ ‘ï¼Œä¸è·³è¡¨å¯¹æ¯”æ€§èƒ½ã€‚

---

## 8. æ€§èƒ½è°ƒä¼˜æ¸…å•

- [ ] ä½¿ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–é€‰é¡¹ï¼ˆ-O2 æˆ– -O3ï¼‰
- [ ] å‡å°‘ä¸å¿…è¦çš„å†…å­˜åˆ†é…
- [ ] ä½¿ç”¨åˆé€‚çš„æœ€å¤§å±‚æ•°ï¼ˆé€šå¸¸ 16-32ï¼‰
- [ ] å¯¹äºå¤šçº¿ç¨‹ï¼Œä½¿ç”¨ç»†ç²’åº¦é”æˆ–è¯»å†™é”
- [ ] è€ƒè™‘ä½¿ç”¨å†…å­˜æ± 
- [ ] é¿å…é¢‘ç¹çš„ç³»ç»Ÿè°ƒç”¨
- [ ] ä½¿ç”¨æ›´å¥½çš„éšæœºæ•°ç”Ÿæˆå™¨

---

## 9. å¸¸è§é—®é¢˜

### Q1ï¼šä¸ºä»€ä¹ˆæˆ‘çš„æµ‹è¯•ç»“æœæ¯”é¢„æœŸæ…¢ï¼Ÿ
Aï¼šå¯èƒ½åŸå› ï¼š
- æ²¡æœ‰ä½¿ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–
- ç¡¬ä»¶æ€§èƒ½å·®å¼‚
- éšæœºæ•°ç”Ÿæˆå™¨æ€§èƒ½å·®
- å†…å­˜åˆ†é…å¼€é”€å¤§

### Q2ï¼šå¦‚ä½•æé«˜ QPSï¼Ÿ
Aï¼š
- ä½¿ç”¨å¤šçº¿ç¨‹
- ä¼˜åŒ–å†…å­˜åˆ†é…
- ä½¿ç”¨æ›´å¥½çš„éšæœºæ•°ç®—æ³•
- å‡å°‘é”ç«äº‰

### Q3ï¼šè·³è¡¨é€‚åˆä»€ä¹ˆåœºæ™¯ï¼Ÿ
Aï¼š
- éœ€è¦æœ‰åºå­˜å‚¨
- éœ€è¦èŒƒå›´æŸ¥è¯¢
- éœ€è¦å¹¶å‘è®¿é—®
- å®ç°ç®€å•æ€§å¾ˆé‡è¦

---

## 10. å…³é”®æ”¶è·

é€šè¿‡é˜¶æ®µ 7ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… æ€§èƒ½æµ‹è¯•æ–¹æ³•
- âœ… QPS å’Œå»¶è¿Ÿçš„è®¡ç®—
- âœ… æ—¶é—´å¤æ‚åº¦çš„éªŒè¯
- âœ… æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- âœ… è·³è¡¨ä¸å…¶ä»–æ•°æ®ç»“æ„çš„å¯¹æ¯”

---

## 11. ä¸‹ä¸€æ­¥

æ­å–œä½ å®Œæˆäº†æ‰€æœ‰æ ¸å¿ƒé˜¶æ®µçš„å­¦ä¹ ï¼

åœ¨æœ€åçš„é˜¶æ®µ 8 ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- æ•´åˆæ‰€æœ‰åŠŸèƒ½
- å®Œå–„é”™è¯¯å¤„ç†
- ä¼˜åŒ–å†…å­˜ç®¡ç†
- å¯¹æ¯”åŸé¡¹ç›®ä»£ç 

ğŸ‘‰ ç»§ç»­å­¦ä¹ ï¼š`09-é˜¶æ®µ8-å®Œæ•´é¡¹ç›®.md`

