# é˜¶æ®µ 5ï¼šæ•°æ®æŒä¹…åŒ– ğŸ’¾

## å­¦ä¹ ç›®æ ‡
- å®ç°æ•°æ®çš„æŒä¹…åŒ–å­˜å‚¨ï¼ˆä¿å­˜åˆ°æ–‡ä»¶ï¼‰
- å®ç°æ•°æ®çš„åŠ è½½ï¼ˆä»æ–‡ä»¶è¯»å–ï¼‰
- ç†è§£æ–‡ä»¶ I/O æ“ä½œ
- è®¾è®¡ç®€å•çš„æ•°æ®å­˜å‚¨æ ¼å¼

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦æŒä¹…åŒ–ï¼Ÿ

### é—®é¢˜

ç›®å‰æˆ‘ä»¬çš„è·³è¡¨æ•°æ®åªå­˜åœ¨äºå†…å­˜ä¸­ï¼š
- ç¨‹åºå…³é—­åï¼Œæ‰€æœ‰æ•°æ®ä¸¢å¤±
- æ— æ³•ä¿å­˜å’Œæ¢å¤æ•°æ®

### è§£å†³æ–¹æ¡ˆ

å°†æ•°æ®ä¿å­˜åˆ°æ–‡ä»¶ä¸­ï¼Œä¸‹æ¬¡å¯åŠ¨æ—¶å¯ä»¥åŠ è½½å›æ¥ã€‚

```
å†…å­˜ä¸­çš„è·³è¡¨ ----dump----> æ–‡ä»¶
                <---load----
```

---

## 2. æ•°æ®å­˜å‚¨æ ¼å¼è®¾è®¡

### ç®€å•çš„é”®å€¼å¯¹æ ¼å¼

æˆ‘ä»¬ä½¿ç”¨æœ€ç®€å•çš„æ–‡æœ¬æ ¼å¼ï¼š

```
key:value
key:value
...
```

**ç¤ºä¾‹æ–‡ä»¶å†…å®¹**ï¼š

```
1:ä¸€
3:ä¸‰
5:äº”
7:ä¸ƒ
9:ä¹
```

**ä¸ºä»€ä¹ˆåªä¿å­˜ Level 0ï¼Ÿ**
- Level 0 åŒ…å«æ‰€æœ‰æ•°æ®
- å…¶ä»–å±‚çš„ç´¢å¼•å¯ä»¥é€šè¿‡éšæœºç®—æ³•é‡å»º
- èŠ‚çœå­˜å‚¨ç©ºé—´

---

## 3. æ ¸å¿ƒæ“ä½œå®ç°

### 3.1 æ•°æ®è½ç›˜ï¼ˆdumpï¼‰

**åŠŸèƒ½**ï¼šå°†è·³è¡¨ä¸­çš„æ‰€æœ‰æ•°æ®ä¿å­˜åˆ°æ–‡ä»¶ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š
1. æ‰“å¼€æ–‡ä»¶ï¼ˆå†™æ¨¡å¼ï¼‰
2. éå† Level 0 çš„æ‰€æœ‰èŠ‚ç‚¹
3. å°†æ¯ä¸ªèŠ‚ç‚¹çš„ key å’Œ value å†™å…¥æ–‡ä»¶
4. å…³é—­æ–‡ä»¶

**ä»£ç å®ç°**ï¼š

```cpp
#include <fstream>

#define STORE_FILE "store/dumpFile"

class SkipList {
private:
    ofstream file_writer;  // æ–‡ä»¶å†™å…¥æµ
    
public:
    void dump_file() {
        cout << "\n--- æ•°æ®è½ç›˜ ---" << endl;
        
        // æ‰“å¼€æ–‡ä»¶ï¼ˆå†™æ¨¡å¼ï¼‰
        file_writer.open(STORE_FILE);
        
        if (!file_writer.is_open()) {
            cout << "âœ— æ— æ³•æ‰“å¼€æ–‡ä»¶: " << STORE_FILE << endl;
            return;
        }
        
        // éå† Level 0
        Node<K, V>* node = header->forward[0];
        int count = 0;
        
        while (node != nullptr) {
            // å†™å…¥æ ¼å¼ï¼škey:value
            file_writer << node->key << ":" << node->value << "\n";
            cout << "å†™å…¥: " << node->key << ":" << node->value << endl;
            
            node = node->forward[0];
            count++;
        }
        
        // åˆ·æ–°ç¼“å†²åŒºå¹¶å…³é—­æ–‡ä»¶
        file_writer.flush();
        file_writer.close();
        
        cout << "âœ“ æˆåŠŸä¿å­˜ " << count << " æ¡æ•°æ®åˆ°æ–‡ä»¶" << endl;
    }
};
```

### 3.2 æ•°æ®åŠ è½½ï¼ˆloadï¼‰

**åŠŸèƒ½**ï¼šä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®å¹¶é‡å»ºè·³è¡¨ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š
1. æ‰“å¼€æ–‡ä»¶ï¼ˆè¯»æ¨¡å¼ï¼‰
2. é€è¡Œè¯»å–æ–‡ä»¶
3. è§£ææ¯ä¸€è¡Œï¼Œæå– key å’Œ value
4. æ’å…¥åˆ°è·³è¡¨ä¸­
5. å…³é—­æ–‡ä»¶

**ä»£ç å®ç°**ï¼š

```cpp
class SkipList {
private:
    ifstream file_reader;  // æ–‡ä»¶è¯»å–æµ
    
    // ä»å­—ç¬¦ä¸²ä¸­è§£æ key å’Œ value
    void get_key_value_from_string(const string& str, string* key, string* value) {
        if (!is_valid_string(str)) {
            return;
        }
        
        // æŸ¥æ‰¾åˆ†éš”ç¬¦ ":"
        size_t pos = str.find(":");
        *key = str.substr(0, pos);
        *value = str.substr(pos + 1, str.length());
    }
    
    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆ
    bool is_valid_string(const string& str) {
        if (str.empty()) {
            return false;
        }
        if (str.find(":") == string::npos) {
            return false;
        }
        return true;
    }
    
public:
    void load_file() {
        cout << "\n--- åŠ è½½æ•°æ® ---" << endl;
        
        // æ‰“å¼€æ–‡ä»¶ï¼ˆè¯»æ¨¡å¼ï¼‰
        file_reader.open(STORE_FILE);
        
        if (!file_reader.is_open()) {
            cout << "âœ— æ— æ³•æ‰“å¼€æ–‡ä»¶: " << STORE_FILE << endl;
            return;
        }
        
        string line;
        string* key = new string();
        string* value = new string();
        int count = 0;
        
        // é€è¡Œè¯»å–
        while (getline(file_reader, line)) {
            // è§£æ key å’Œ value
            get_key_value_from_string(line, key, value);
            
            if (key->empty() || value->empty()) {
                continue;
            }
            
            // æ’å…¥åˆ°è·³è¡¨ï¼ˆå‡è®¾ key æ˜¯ int ç±»å‹ï¼‰
            insert(stoi(*key), *value);
            count++;
        }
        
        delete key;
        delete value;
        file_reader.close();
        
        cout << "âœ“ æˆåŠŸåŠ è½½ " << count << " æ¡æ•°æ®" << endl;
    }
};
```

---

## 4. å®Œæ•´ä»£ç ç¤ºä¾‹

**æ–‡ä»¶å**ï¼š`stage5_persistence.h`

```cpp
#ifndef STAGE5_PERSISTENCE_H
#define STAGE5_PERSISTENCE_H

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <string>
using namespace std;

#define STORE_FILE "store/dumpFile"

// èŠ‚ç‚¹ç±»
template<typename K, typename V>
class Node {
public:
    K key;
    V value;
    Node<K, V>** forward;
    int node_level;
    
    Node(K k, V v, int level) {
        key = k;
        value = v;
        node_level = level;
        forward = new Node<K, V>*[level + 1];
        for (int i = 0; i <= level; i++) {
            forward[i] = nullptr;
        }
    }
    
    ~Node() {
        delete[] forward;
    }
};

// è·³è¡¨ç±»ï¼ˆå¸¦æŒä¹…åŒ–åŠŸèƒ½ï¼‰
template<typename K, typename V>
class SkipList {
private:
    int max_level;
    int current_level;
    Node<K, V>* header;
    int element_count;
    
    ofstream file_writer;
    ifstream file_reader;
    
    // è§£æå­—ç¬¦ä¸²
    void get_key_value_from_string(const string& str, string* key, string* value) {
        if (!is_valid_string(str)) {
            return;
        }
        size_t pos = str.find(":");
        *key = str.substr(0, pos);
        *value = str.substr(pos + 1, str.length());
    }
    
    // éªŒè¯å­—ç¬¦ä¸²
    bool is_valid_string(const string& str) {
        if (str.empty()) return false;
        if (str.find(":") == string::npos) return false;
        return true;
    }
    
public:
    SkipList(int max_lvl) : max_level(max_lvl), current_level(0), element_count(0) {
        srand(time(nullptr));
        K k;
        V v;
        header = new Node<K, V>(k, v, max_level);
        cout << "è·³è¡¨å·²åˆ›å»º" << endl;
    }
    
    ~SkipList() {
        if (file_writer.is_open()) {
            file_writer.close();
        }
        if (file_reader.is_open()) {
            file_reader.close();
        }
        
        Node<K, V>* current = header->forward[0];
        while (current != nullptr) {
            Node<K, V>* temp = current;
            current = current->forward[0];
            delete temp;
        }
        delete header;
        cout << "è·³è¡¨å·²é”€æ¯" << endl;
    }
    
    int get_random_level() {
        int level = 0;
        while (rand() % 2 && level < max_level) {
            level++;
        }
        return level;
    }
    
    void insert(K key, V value) {
        Node<K, V>* current = header;
        Node<K, V>* update[max_level + 1];
        
        for (int i = 0; i <= max_level; i++) {
            update[i] = nullptr;
        }
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
            update[i] = current;
        }
        
        current = current->forward[0];
        
        if (current != nullptr && current->key == key) {
            cout << "key=" << key << " å·²å­˜åœ¨" << endl;
            return;
        }
        
        int random_level = get_random_level();
        
        if (random_level > current_level) {
            for (int i = current_level + 1; i <= random_level; i++) {
                update[i] = header;
            }
            current_level = random_level;
        }
        
        Node<K, V>* new_node = new Node<K, V>(key, value, random_level);
        
        for (int i = 0; i <= random_level; i++) {
            new_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = new_node;
        }
        
        element_count++;
        cout << "æ’å…¥æˆåŠŸ: key=" << key << ", value=" << value << endl;
    }
    
    bool search(K key) {
        Node<K, V>* current = header;
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
        }
        
        current = current->forward[0];
        
        if (current != nullptr && current->key == key) {
            cout << "æ‰¾åˆ° key=" << key << ", value=" << current->value << endl;
            return true;
        }
        
        cout << "æœªæ‰¾åˆ° key=" << key << endl;
        return false;
    }
    
    void display() {
        cout << "\n========== è·³è¡¨ç»“æ„ ==========" << endl;
        for (int i = current_level; i >= 0; i--) {
            Node<K, V>* node = header->forward[i];
            cout << "Level " << i << ": ";
            while (node != nullptr) {
                cout << "[" << node->key << ":" << node->value << "]";
                if (node->forward[i] != nullptr) {
                    cout << " -> ";
                }
                node = node->forward[i];
            }
            cout << " -> NULL" << endl;
        }
        cout << "å…ƒç´ ä¸ªæ•°: " << element_count << endl;
        cout << "==============================" << endl;
    }
    
    // æ•°æ®è½ç›˜
    void dump_file() {
        cout << "\n--- æ•°æ®è½ç›˜ ---" << endl;
        
        file_writer.open(STORE_FILE);
        
        if (!file_writer.is_open()) {
            cout << "âœ— æ— æ³•æ‰“å¼€æ–‡ä»¶: " << STORE_FILE << endl;
            return;
        }
        
        Node<K, V>* node = header->forward[0];
        int count = 0;
        
        while (node != nullptr) {
            file_writer << node->key << ":" << node->value << "\n";
            cout << "å†™å…¥: " << node->key << ":" << node->value << endl;
            node = node->forward[0];
            count++;
        }
        
        file_writer.flush();
        file_writer.close();
        
        cout << "âœ“ æˆåŠŸä¿å­˜ " << count << " æ¡æ•°æ®åˆ°æ–‡ä»¶" << endl;
    }
    
    // åŠ è½½æ•°æ®
    void load_file() {
        cout << "\n--- åŠ è½½æ•°æ® ---" << endl;
        
        file_reader.open(STORE_FILE);
        
        if (!file_reader.is_open()) {
            cout << "âœ— æ— æ³•æ‰“å¼€æ–‡ä»¶: " << STORE_FILE << endl;
            return;
        }
        
        string line;
        string* key = new string();
        string* value = new string();
        int count = 0;
        
        while (getline(file_reader, line)) {
            get_key_value_from_string(line, key, value);
            
            if (key->empty() || value->empty()) {
                continue;
            }
            
            // å‡è®¾ key æ˜¯ int ç±»å‹
            insert(stoi(*key), *value);
            count++;
        }
        
        delete key;
        delete value;
        file_reader.close();
        
        cout << "âœ“ æˆåŠŸåŠ è½½ " << count << " æ¡æ•°æ®" << endl;
    }
    
    int size() {
        return element_count;
    }
};

#endif
```

---

## 5. æ¼”ç¤ºç¨‹åº

**æ–‡ä»¶å**ï¼š`stage5_demo.cpp`

```cpp
#include "stage5_persistence.h"
#include <sys/stat.h>

// åˆ›å»ºç›®å½•çš„è¾…åŠ©å‡½æ•°
void create_store_directory() {
    struct stat info;
    if (stat("store", &info) != 0) {
        // ç›®å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
        #ifdef _WIN32
            _mkdir("store");
        #else
            mkdir("store", 0755);
        #endif
        cout << "åˆ›å»º store ç›®å½•" << endl;
    }
}

int main() {
    cout << "========================================" << endl;
    cout << "  é˜¶æ®µ5ï¼šæ•°æ®æŒä¹…åŒ–æ¼”ç¤º" << endl;
    cout << "========================================\n" << endl;
    
    // åˆ›å»ºå­˜å‚¨ç›®å½•
    create_store_directory();
    
    // ç¬¬ä¸€éƒ¨åˆ†ï¼šåˆ›å»ºè·³è¡¨å¹¶ä¿å­˜æ•°æ®
    {
        cout << "\nã€ç¬¬ä¸€éƒ¨åˆ†ï¼šåˆ›å»ºè·³è¡¨å¹¶ä¿å­˜æ•°æ®ã€‘" << endl;
        cout << "-----------------------------------" << endl;
        
        SkipList<int, string> skipList(6);
        
        skipList.insert(1, "ä¸€");
        skipList.insert(3, "ä¸‰");
        skipList.insert(7, "ä¸ƒ");
        skipList.insert(8, "å…«");
        skipList.insert(9, "ä¹");
        skipList.insert(19, "åä¹");
        
        skipList.display();
        
        // ä¿å­˜åˆ°æ–‡ä»¶
        skipList.dump_file();
        
        cout << "\nè·³è¡¨å³å°†é”€æ¯..." << endl;
    }  // skipList åœ¨è¿™é‡Œè¢«é”€æ¯
    
    // ç¬¬äºŒéƒ¨åˆ†ï¼šåˆ›å»ºæ–°è·³è¡¨å¹¶åŠ è½½æ•°æ®
    {
        cout << "\n\nã€ç¬¬äºŒéƒ¨åˆ†ï¼šåˆ›å»ºæ–°è·³è¡¨å¹¶åŠ è½½æ•°æ®ã€‘" << endl;
        cout << "-----------------------------------" << endl;
        
        SkipList<int, string> newSkipList(6);
        
        cout << "æ–°è·³è¡¨åˆå§‹çŠ¶æ€ï¼š" << endl;
        newSkipList.display();
        
        // ä»æ–‡ä»¶åŠ è½½
        newSkipList.load_file();
        
        cout << "\nåŠ è½½åçš„è·³è¡¨ï¼š" << endl;
        newSkipList.display();
        
        // éªŒè¯æ•°æ®
        cout << "\nã€éªŒè¯æ•°æ®ã€‘" << endl;
        cout << "-----------------------------------" << endl;
        newSkipList.search(7);
        newSkipList.search(19);
        newSkipList.search(100);
    }
    
    cout << "\n========================================" << endl;
    cout << "  æ¼”ç¤ºç»“æŸ" << endl;
    cout << "========================================" << endl;
    
    return 0;
}
```

---

## 6. ç¼–è¯‘å’Œè¿è¡Œ

### ç¼–è¯‘

```bash
cd /Users/cjx/Downloads/Skiplist-CPP-master/learning-plan
g++ -std=c++11 -o stage5 stage5_demo.cpp
```

### è¿è¡Œ

```bash
./stage5
```

### æŸ¥çœ‹ä¿å­˜çš„æ–‡ä»¶

```bash
cat store/dumpFile
```

---

## 7. ç»ƒä¹ é¢˜

### ç»ƒä¹  1ï¼šäºŒè¿›åˆ¶æ ¼å¼
å°†æ–‡æœ¬æ ¼å¼æ”¹ä¸ºäºŒè¿›åˆ¶æ ¼å¼ï¼Œæé«˜å­˜å‚¨æ•ˆç‡ã€‚

### ç»ƒä¹  2ï¼šä¿å­˜å±‚æ•°ä¿¡æ¯
åœ¨æ–‡ä»¶ä¸­ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„å±‚æ•°ï¼ŒåŠ è½½æ—¶æ¢å¤åŸæœ‰ç»“æ„ã€‚

### ç»ƒä¹  3ï¼šå‹ç¼©å­˜å‚¨
å®ç°ç®€å•çš„æ•°æ®å‹ç¼©ï¼Œå‡å°æ–‡ä»¶å¤§å°ã€‚

---

## 8. å¸¸è§é—®é¢˜

### Q1ï¼šä¸ºä»€ä¹ˆä¸ä¿å­˜æ‰€æœ‰å±‚çš„ä¿¡æ¯ï¼Ÿ
Aï¼šLevel 0 åŒ…å«æ‰€æœ‰æ•°æ®ï¼Œå…¶ä»–å±‚å¯ä»¥é€šè¿‡éšæœºç®—æ³•é‡å»ºï¼ŒèŠ‚çœç©ºé—´ã€‚

### Q2ï¼šå¦‚æœæ–‡ä»¶æŸåæ€ä¹ˆåŠï¼Ÿ
Aï¼šå¯ä»¥æ·»åŠ æ ¡éªŒå’Œï¼ˆchecksumï¼‰éªŒè¯æ•°æ®å®Œæ•´æ€§ã€‚

### Q3ï¼šå¦‚ä½•å¤„ç†å¤§æ–‡ä»¶ï¼Ÿ
Aï¼šå¯ä»¥åˆ†æ‰¹è¯»å–ï¼Œæˆ–ä½¿ç”¨å†…å­˜æ˜ å°„æ–‡ä»¶ï¼ˆmmapï¼‰ã€‚

---

## 9. å…³é”®æ”¶è·

é€šè¿‡é˜¶æ®µ 5ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… æ–‡ä»¶ I/O æ“ä½œï¼ˆofstreamã€ifstreamï¼‰
- âœ… æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
- âœ… å­—ç¬¦ä¸²è§£æ
- âœ… æ•°æ®æŒä¹…åŒ–çš„åŸºæœ¬æ€æƒ³

---

## 10. ä¸‹ä¸€æ­¥

åœ¨é˜¶æ®µ 6 ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- æ·»åŠ äº’æ–¥é”ï¼ˆmutexï¼‰
- å®ç°çº¿ç¨‹å®‰å…¨çš„è·³è¡¨
- æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®

ğŸ‘‰ ç»§ç»­å­¦ä¹ ï¼š`07-é˜¶æ®µ6-çº¿ç¨‹å®‰å…¨.md`

