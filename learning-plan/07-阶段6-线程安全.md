# é˜¶æ®µ 6ï¼šçº¿ç¨‹å®‰å…¨ ğŸ”’

## å­¦ä¹ ç›®æ ‡
- ç†è§£å¤šçº¿ç¨‹å¹¶å‘è®¿é—®çš„é—®é¢˜
- å­¦ä¹ äº’æ–¥é”ï¼ˆmutexï¼‰çš„ä½¿ç”¨
- å®ç°çº¿ç¨‹å®‰å…¨çš„è·³è¡¨
- æµ‹è¯•å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„æ­£ç¡®æ€§

---

## 1. ä¸ºä»€ä¹ˆéœ€è¦çº¿ç¨‹å®‰å…¨ï¼Ÿ

### é—®é¢˜åœºæ™¯

å‡è®¾ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œè·³è¡¨ï¼š

```
çº¿ç¨‹ Aï¼šæ’å…¥ key=5
çº¿ç¨‹ Bï¼šæ’å…¥ key=6

æ—¶é—´çº¿ï¼š
t1: çº¿ç¨‹ A è¯»å– header->forward[0]
t2: çº¿ç¨‹ B è¯»å– header->forward[0]  (è¯»åˆ°ç›¸åŒçš„å€¼)
t3: çº¿ç¨‹ A æ’å…¥èŠ‚ç‚¹ 5
t4: çº¿ç¨‹ B æ’å…¥èŠ‚ç‚¹ 6  (è¦†ç›–äº†èŠ‚ç‚¹ 5 çš„æ’å…¥ï¼)

ç»“æœï¼šèŠ‚ç‚¹ 5 ä¸¢å¤±ï¼
```

### ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰

å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ®ï¼Œç»“æœå–å†³äºæ‰§è¡Œé¡ºåºï¼Œå¯¼è‡´ä¸å¯é¢„æµ‹çš„è¡Œä¸ºã€‚

---

## 2. äº’æ–¥é”ï¼ˆMutexï¼‰

### ä»€ä¹ˆæ˜¯ Mutexï¼Ÿ

Mutexï¼ˆMutual Exclusionï¼Œäº’æ–¥ï¼‰æ˜¯ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºã€‚

```cpp
#include <mutex>

std::mutex mtx;  // åˆ›å»ºäº’æ–¥é”

// ä½¿ç”¨äº’æ–¥é”
mtx.lock();      // åŠ é”
// ... è®¿é—®å…±äº«èµ„æº ...
mtx.unlock();    // è§£é”
```

### å·¥ä½œåŸç†

```
çº¿ç¨‹ Aï¼š
  mtx.lock()    âœ“ è·å¾—é”
  æ’å…¥èŠ‚ç‚¹ 5
  mtx.unlock()  é‡Šæ”¾é”

çº¿ç¨‹ Bï¼š
  mtx.lock()    âœ— ç­‰å¾…ï¼ˆçº¿ç¨‹ A æŒæœ‰é”ï¼‰
  ...           ç­‰å¾…ä¸­...
  mtx.lock()    âœ“ è·å¾—é”ï¼ˆçº¿ç¨‹ A é‡Šæ”¾åï¼‰
  æ’å…¥èŠ‚ç‚¹ 6
  mtx.unlock()  é‡Šæ”¾é”
```

---

## 3. å®ç°çº¿ç¨‹å®‰å…¨çš„è·³è¡¨

### 3.1 æ·»åŠ äº’æ–¥é”

```cpp
#include <mutex>

std::mutex mtx;  // å…¨å±€äº’æ–¥é”

template<typename K, typename V>
class SkipList {
    // ... å…¶ä»–æˆå‘˜ ...
    
public:
    void insert(K key, V value) {
        mtx.lock();  // ğŸ”’ åŠ é”
        
        // ... æ’å…¥é€»è¾‘ ...
        
        mtx.unlock();  // ğŸ”“ è§£é”
    }
    
    void remove(K key) {
        mtx.lock();  // ğŸ”’ åŠ é”
        
        // ... åˆ é™¤é€»è¾‘ ...
        
        mtx.unlock();  // ğŸ”“ è§£é”
    }
    
    // æ³¨æ„ï¼šsearch é€šå¸¸ä¸éœ€è¦åŠ é”ï¼ˆåªè¯»æ“ä½œï¼‰
    // ä½†ä¸ºäº†ç»å¯¹å®‰å…¨ï¼Œä¹Ÿå¯ä»¥åŠ é”
};
```

### 3.2 ä½¿ç”¨ lock_guardï¼ˆæ¨èï¼‰

æ‰‹åŠ¨ `lock()` å’Œ `unlock()` å®¹æ˜“å‡ºé”™ï¼ˆå¿˜è®°è§£é”ã€å¼‚å¸¸å¯¼è‡´æœªè§£é”ï¼‰ã€‚

**æ›´å¥½çš„æ–¹å¼**ï¼šä½¿ç”¨ `std::lock_guard`

```cpp
void insert(K key, V value) {
    std::lock_guard<std::mutex> lock(mtx);  // è‡ªåŠ¨åŠ é”
    
    // ... æ’å…¥é€»è¾‘ ...
    
    // å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨è§£é”ï¼ˆå³ä½¿å‘ç”Ÿå¼‚å¸¸ï¼‰
}
```

**ä¼˜åŠ¿**ï¼š
- è‡ªåŠ¨ç®¡ç†é”çš„ç”Ÿå‘½å‘¨æœŸ
- å¼‚å¸¸å®‰å…¨ï¼ˆRAII åŸåˆ™ï¼‰
- ä»£ç æ›´ç®€æ´

---

## 4. å®Œæ•´ä»£ç ç¤ºä¾‹

**æ–‡ä»¶å**ï¼š`stage6_thread_safe.h`

```cpp
#ifndef STAGE6_THREAD_SAFE_H
#define STAGE6_THREAD_SAFE_H

#include <iostream>
#include <mutex>
#include <cstdlib>
#include <ctime>
using namespace std;

std::mutex mtx;  // å…¨å±€äº’æ–¥é”

// èŠ‚ç‚¹ç±»
template<typename K, typename V>
class Node {
public:
    K key;
    V value;
    Node<K, V>** forward;
    int node_level;
    
    Node(K k, V v, int level) {
        key = k;
        value = v;
        node_level = level;
        forward = new Node<K, V>*[level + 1];
        for (int i = 0; i <= level; i++) {
            forward[i] = nullptr;
        }
    }
    
    ~Node() {
        delete[] forward;
    }
};

// çº¿ç¨‹å®‰å…¨çš„è·³è¡¨ç±»
template<typename K, typename V>
class SkipList {
private:
    int max_level;
    int current_level;
    Node<K, V>* header;
    int element_count;
    
public:
    SkipList(int max_lvl) : max_level(max_lvl), current_level(0), element_count(0) {
        srand(time(nullptr));
        K k;
        V v;
        header = new Node<K, V>(k, v, max_level);
        cout << "çº¿ç¨‹å®‰å…¨è·³è¡¨å·²åˆ›å»º" << endl;
    }
    
    ~SkipList() {
        Node<K, V>* current = header->forward[0];
        while (current != nullptr) {
            Node<K, V>* temp = current;
            current = current->forward[0];
            delete temp;
        }
        delete header;
        cout << "çº¿ç¨‹å®‰å…¨è·³è¡¨å·²é”€æ¯" << endl;
    }
    
    int get_random_level() {
        int level = 0;
        while (rand() % 2 && level < max_level) {
            level++;
        }
        return level;
    }
    
    // çº¿ç¨‹å®‰å…¨çš„æ’å…¥
    void insert(K key, V value) {
        mtx.lock();  // ğŸ”’ åŠ é”
        
        Node<K, V>* current = header;
        Node<K, V>* update[max_level + 1];
        
        for (int i = 0; i <= max_level; i++) {
            update[i] = nullptr;
        }
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
            update[i] = current;
        }
        
        current = current->forward[0];
        
        if (current != nullptr && current->key == key) {
            cout << "key=" << key << " å·²å­˜åœ¨" << endl;
            mtx.unlock();  // ğŸ”“ è§£é”
            return;
        }
        
        int random_level = get_random_level();
        
        if (random_level > current_level) {
            for (int i = current_level + 1; i <= random_level; i++) {
                update[i] = header;
            }
            current_level = random_level;
        }
        
        Node<K, V>* new_node = new Node<K, V>(key, value, random_level);
        
        for (int i = 0; i <= random_level; i++) {
            new_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = new_node;
        }
        
        element_count++;
        cout << "æ’å…¥æˆåŠŸ: key=" << key << ", value=" << value << endl;
        
        mtx.unlock();  // ğŸ”“ è§£é”
    }
    
    // çº¿ç¨‹å®‰å…¨çš„åˆ é™¤
    void remove(K key) {
        mtx.lock();  // ğŸ”’ åŠ é”
        
        Node<K, V>* current = header;
        Node<K, V>* update[max_level + 1];
        
        for (int i = 0; i <= max_level; i++) {
            update[i] = nullptr;
        }
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
            update[i] = current;
        }
        
        current = current->forward[0];
        
        if (current == nullptr || current->key != key) {
            cout << "æœªæ‰¾åˆ° key=" << key << endl;
            mtx.unlock();  // ğŸ”“ è§£é”
            return;
        }
        
        for (int i = 0; i <= current_level; i++) {
            if (update[i]->forward[i] != current) {
                break;
            }
            update[i]->forward[i] = current->forward[i];
        }
        
        delete current;
        element_count--;
        
        while (current_level > 0 && 
               header->forward[current_level] == nullptr) {
            current_level--;
        }
        
        cout << "åˆ é™¤æˆåŠŸ: key=" << key << endl;
        
        mtx.unlock();  // ğŸ”“ è§£é”
    }
    
    // æŸ¥æ‰¾ï¼ˆåªè¯»æ“ä½œï¼Œå¯ä»¥ä¸åŠ é”ï¼Œä½†ä¸ºäº†å®‰å…¨ä¹ŸåŠ é”ï¼‰
    bool search(K key) {
        // å¯¹äºåªè¯»æ“ä½œï¼Œå¯ä»¥é€‰æ‹©ä¸åŠ é”ä»¥æé«˜æ€§èƒ½
        // ä½†è¿™é‡Œä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬ä¹ŸåŠ é”
        mtx.lock();  // ğŸ”’ åŠ é”
        
        Node<K, V>* current = header;
        
        for (int i = current_level; i >= 0; i--) {
            while (current->forward[i] != nullptr && 
                   current->forward[i]->key < key) {
                current = current->forward[i];
            }
        }
        
        current = current->forward[0];
        
        bool found = (current != nullptr && current->key == key);
        
        mtx.unlock();  // ğŸ”“ è§£é”
        
        return found;
    }
    
    void display() {
        mtx.lock();  // ğŸ”’ åŠ é”
        
        cout << "\n========== è·³è¡¨ç»“æ„ ==========" << endl;
        for (int i = current_level; i >= 0; i--) {
            Node<K, V>* node = header->forward[i];
            cout << "Level " << i << ": ";
            while (node != nullptr) {
                cout << "[" << node->key << ":" << node->value << "]";
                if (node->forward[i] != nullptr) {
                    cout << " -> ";
                }
                node = node->forward[i];
            }
            cout << " -> NULL" << endl;
        }
        cout << "å…ƒç´ ä¸ªæ•°: " << element_count << endl;
        cout << "==============================" << endl;
        
        mtx.unlock();  // ğŸ”“ è§£é”
    }
    
    int size() {
        mtx.lock();
        int count = element_count;
        mtx.unlock();
        return count;
    }
};

#endif
```

---

## 5. å¤šçº¿ç¨‹æµ‹è¯•ç¨‹åº

**æ–‡ä»¶å**ï¼š`stage6_demo.cpp`

```cpp
#include "stage6_thread_safe.h"
#include <pthread.h>
#include <chrono>

#define NUM_THREADS 4
#define TEST_COUNT 100

SkipList<int, string> skipList(18);

// çº¿ç¨‹å‡½æ•°ï¼šæ’å…¥å…ƒç´ 
void* insert_element(void* threadid) {
    long tid = (long)threadid;
    cout << "çº¿ç¨‹ " << tid << " å¼€å§‹æ’å…¥..." << endl;
    
    int start = tid * TEST_COUNT;
    for (int i = start; i < start + TEST_COUNT; i++) {
        skipList.insert(i, "å€¼" + to_string(i));
    }
    
    cout << "çº¿ç¨‹ " << tid << " å®Œæˆæ’å…¥" << endl;
    pthread_exit(nullptr);
}

// çº¿ç¨‹å‡½æ•°ï¼šæŸ¥æ‰¾å…ƒç´ 
void* search_element(void* threadid) {
    long tid = (long)threadid;
    cout << "çº¿ç¨‹ " << tid << " å¼€å§‹æŸ¥æ‰¾..." << endl;
    
    int start = tid * TEST_COUNT;
    int found_count = 0;
    
    for (int i = start; i < start + TEST_COUNT; i++) {
        if (skipList.search(i)) {
            found_count++;
        }
    }
    
    cout << "çº¿ç¨‹ " << tid << " å®ŒæˆæŸ¥æ‰¾ï¼Œæ‰¾åˆ° " << found_count << " ä¸ªå…ƒç´ " << endl;
    pthread_exit(nullptr);
}

int main() {
    cout << "========================================" << endl;
    cout << "  é˜¶æ®µ6ï¼šçº¿ç¨‹å®‰å…¨æ¼”ç¤º" << endl;
    cout << "========================================\n" << endl;
    
    // æµ‹è¯•1ï¼šå¤šçº¿ç¨‹æ’å…¥
    {
        cout << "\nã€æµ‹è¯•1ï¼šå¤šçº¿ç¨‹æ’å…¥ã€‘" << endl;
        cout << "ä½¿ç”¨ " << NUM_THREADS << " ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªæ’å…¥ " << TEST_COUNT << " ä¸ªå…ƒç´ " << endl;
        cout << "-----------------------------------" << endl;
        
        pthread_t threads[NUM_THREADS];
        auto start = chrono::high_resolution_clock::now();
        
        // åˆ›å»ºçº¿ç¨‹
        for (int i = 0; i < NUM_THREADS; i++) {
            int rc = pthread_create(&threads[i], nullptr, insert_element, (void*)(long)i);
            if (rc) {
                cout << "é”™è¯¯ï¼šæ— æ³•åˆ›å»ºçº¿ç¨‹ " << i << endl;
                exit(-1);
            }
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (int i = 0; i < NUM_THREADS; i++) {
            pthread_join(threads[i], nullptr);
        }
        
        auto finish = chrono::high_resolution_clock::now();
        chrono::duration<double> elapsed = finish - start;
        
        cout << "\næ’å…¥å®Œæˆï¼" << endl;
        cout << "æ€»è€—æ—¶: " << elapsed.count() << " ç§’" << endl;
        cout << "è·³è¡¨å¤§å°: " << skipList.size() << endl;
        cout << "é¢„æœŸå¤§å°: " << NUM_THREADS * TEST_COUNT << endl;
    }
    
    // æµ‹è¯•2ï¼šå¤šçº¿ç¨‹æŸ¥æ‰¾
    {
        cout << "\nã€æµ‹è¯•2ï¼šå¤šçº¿ç¨‹æŸ¥æ‰¾ã€‘" << endl;
        cout << "ä½¿ç”¨ " << NUM_THREADS << " ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªæŸ¥æ‰¾ " << TEST_COUNT << " ä¸ªå…ƒç´ " << endl;
        cout << "-----------------------------------" << endl;
        
        pthread_t threads[NUM_THREADS];
        auto start = chrono::high_resolution_clock::now();
        
        // åˆ›å»ºçº¿ç¨‹
        for (int i = 0; i < NUM_THREADS; i++) {
            int rc = pthread_create(&threads[i], nullptr, search_element, (void*)(long)i);
            if (rc) {
                cout << "é”™è¯¯ï¼šæ— æ³•åˆ›å»ºçº¿ç¨‹ " << i << endl;
                exit(-1);
            }
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (int i = 0; i < NUM_THREADS; i++) {
            pthread_join(threads[i], nullptr);
        }
        
        auto finish = chrono::high_resolution_clock::now();
        chrono::duration<double> elapsed = finish - start;
        
        cout << "\næŸ¥æ‰¾å®Œæˆï¼" << endl;
        cout << "æ€»è€—æ—¶: " << elapsed.count() << " ç§’" << endl;
    }
    
    cout << "\n========================================" << endl;
    cout << "  æ¼”ç¤ºç»“æŸ" << endl;
    cout << "========================================" << endl;
    
    pthread_exit(nullptr);
    return 0;
}
```

---

## 6. ç¼–è¯‘å’Œè¿è¡Œ

### ç¼–è¯‘

```bash
cd /Users/cjx/Downloads/Skiplist-CPP-master/learning-plan
g++ -std=c++11 -pthread -o stage6 stage6_demo.cpp
```

**æ³¨æ„**ï¼šéœ€è¦æ·»åŠ  `-pthread` é€‰é¡¹ä»¥æ”¯æŒå¤šçº¿ç¨‹ã€‚

### è¿è¡Œ

```bash
./stage6
```

---

## 7. æ€§èƒ½è€ƒè™‘

### é”çš„ç²’åº¦

**ç²—ç²’åº¦é”**ï¼ˆå½“å‰å®ç°ï¼‰ï¼š
- æ•´ä¸ªæ“ä½œåŠ ä¸€æŠŠå¤§é”
- ç®€å•ï¼Œä½†å¹¶å‘æ€§èƒ½è¾ƒä½

**ç»†ç²’åº¦é”**ï¼ˆä¼˜åŒ–æ–¹å‘ï¼‰ï¼š
- ä¸ºæ¯ä¸ªèŠ‚ç‚¹æˆ–æ¯ä¸€å±‚åŠ é”
- å¤æ‚ï¼Œä½†å¹¶å‘æ€§èƒ½æ›´é«˜

### è¯»å†™é”

å¯¹äºè¯»å¤šå†™å°‘çš„åœºæ™¯ï¼Œå¯ä»¥ä½¿ç”¨ `std::shared_mutex`ï¼š
- å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»
- å†™æ“ä½œç‹¬å é”

```cpp
#include <shared_mutex>

std::shared_mutex rw_mtx;

// è¯»æ“ä½œ
void search(K key) {
    std::shared_lock<std::shared_mutex> lock(rw_mtx);
    // ... æŸ¥æ‰¾é€»è¾‘ ...
}

// å†™æ“ä½œ
void insert(K key, V value) {
    std::unique_lock<std::shared_mutex> lock(rw_mtx);
    // ... æ’å…¥é€»è¾‘ ...
}
```

---

## 8. ç»ƒä¹ é¢˜

### ç»ƒä¹  1ï¼šæ­»é”æ£€æµ‹
å°è¯•åˆ›å»ºä¸€ä¸ªä¼šå¯¼è‡´æ­»é”çš„åœºæ™¯ï¼Œå¹¶è§£å†³å®ƒã€‚

### ç»ƒä¹  2ï¼šè¯»å†™é”
å°†äº’æ–¥é”æ”¹ä¸ºè¯»å†™é”ï¼Œæµ‹è¯•æ€§èƒ½æå‡ã€‚

### ç»ƒä¹  3ï¼šæ— é”è·³è¡¨
ç ”ç©¶æ— é”æ•°æ®ç»“æ„ï¼ˆlock-freeï¼‰ï¼Œå°è¯•å®ç°æ— é”è·³è¡¨ã€‚

---

## 9. å¸¸è§é—®é¢˜

### Q1ï¼šä¸ºä»€ä¹ˆæŸ¥æ‰¾ä¹Ÿè¦åŠ é”ï¼Ÿ
Aï¼šè™½ç„¶æŸ¥æ‰¾æ˜¯åªè¯»æ“ä½œï¼Œä½†å¦‚æœå…¶ä»–çº¿ç¨‹æ­£åœ¨ä¿®æ”¹ç»“æ„ï¼Œå¯èƒ½è¯»åˆ°ä¸ä¸€è‡´çš„æ•°æ®ã€‚

### Q2ï¼šé”ä¼šå½±å“æ€§èƒ½å—ï¼Ÿ
Aï¼šä¼šã€‚ä½†æ­£ç¡®æ€§æ¯”æ€§èƒ½æ›´é‡è¦ã€‚å¯ä»¥é€šè¿‡ç»†ç²’åº¦é”æˆ–è¯»å†™é”ä¼˜åŒ–ã€‚

### Q3ï¼šå¦‚ä½•é¿å…æ­»é”ï¼Ÿ
Aï¼š
1. æŒ‰å›ºå®šé¡ºåºè·å–é”
2. ä½¿ç”¨è¶…æ—¶æœºåˆ¶
3. é¿å…åµŒå¥—é”

---

## 10. å…³é”®æ”¶è·

é€šè¿‡é˜¶æ®µ 6ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š
- âœ… å¤šçº¿ç¨‹å¹¶å‘é—®é¢˜
- âœ… äº’æ–¥é”ï¼ˆmutexï¼‰çš„ä½¿ç”¨
- âœ… RAII åŸåˆ™ï¼ˆlock_guardï¼‰
- âœ… çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„è®¾è®¡
- âœ… pthread å¤šçº¿ç¨‹ç¼–ç¨‹

---

## 11. ä¸‹ä¸€æ­¥

åœ¨é˜¶æ®µ 7 ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- è¿›è¡Œå¤§è§„æ¨¡æ€§èƒ½æµ‹è¯•
- è®¡ç®— QPSï¼ˆæ¯ç§’æŸ¥è¯¢æ•°ï¼‰
- åˆ†ææ—¶é—´å¤æ‚åº¦
- ä¸å…¶ä»–æ•°æ®ç»“æ„å¯¹æ¯”

ğŸ‘‰ ç»§ç»­å­¦ä¹ ï¼š`08-é˜¶æ®µ7-æ€§èƒ½æµ‹è¯•.md`

