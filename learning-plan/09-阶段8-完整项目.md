# é˜¶æ®µ 8ï¼šå®Œæ•´é¡¹ç›®æ•´åˆ ğŸ“

## å­¦ä¹ ç›®æ ‡
- æ•´åˆæ‰€æœ‰åŠŸèƒ½ï¼Œå®Œæˆå®Œæ•´çš„ KV å­˜å‚¨å¼•æ“
- å¯¹æ¯”åŸé¡¹ç›®ä»£ç ï¼Œç†è§£è®¾è®¡æ€æƒ³
- å®Œå–„é”™è¯¯å¤„ç†å’Œå†…å­˜ç®¡ç†
- æ€»ç»“å­¦ä¹ æˆæœ

---

## 1. åŠŸèƒ½æ¸…å•

ç»è¿‡å‰é¢ 7 ä¸ªé˜¶æ®µçš„å­¦ä¹ ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†ï¼š

- âœ… æœ‰åºé“¾è¡¨ï¼ˆé˜¶æ®µ 1ï¼‰
- âœ… åŒå±‚è·³è¡¨ï¼ˆé˜¶æ®µ 2ï¼‰
- âœ… å¤šå±‚è·³è¡¨ï¼ˆé˜¶æ®µ 3ï¼‰
- âœ… æ¨¡æ¿åŒ–è®¾è®¡ï¼ˆé˜¶æ®µ 4ï¼‰
- âœ… æ•°æ®æŒä¹…åŒ–ï¼ˆé˜¶æ®µ 5ï¼‰
- âœ… çº¿ç¨‹å®‰å…¨ï¼ˆé˜¶æ®µ 6ï¼‰
- âœ… æ€§èƒ½æµ‹è¯•ï¼ˆé˜¶æ®µ 7ï¼‰

ç°åœ¨ï¼Œæˆ‘ä»¬å°†è¿™äº›åŠŸèƒ½æ•´åˆæˆä¸€ä¸ªå®Œæ•´çš„é¡¹ç›®ã€‚

---

## 2. å®Œæ•´çš„è·³è¡¨å®ç°

### å¯¹æ¯”åŸé¡¹ç›®

è®©æˆ‘ä»¬å¯¹æ¯”ä¸€ä¸‹åŸé¡¹ç›® `skiplist.h` çš„å…³é”®éƒ¨åˆ†ï¼š

**åŸé¡¹ç›®çš„èŠ‚ç‚¹å®šä¹‰**ï¼š

```cpp
template<typename K, typename V> 
class Node {
public:
    Node() {} 
    Node(K k, V v, int);
    ~Node();
    K get_key() const;
    V get_value() const;
    void set_value(V);
    
    Node<K, V> **forward;  // æŒ‡é’ˆæ•°ç»„
    int node_level;
    
private:
    K key;
    V value;
};
```

**æˆ‘ä»¬çš„å®ç°**ï¼š

```cpp
template<typename K, typename V>
class Node {
public:
    K key;
    V value;
    Node<K, V>** forward;
    int node_level;
    
    Node(K k, V v, int level) {
        key = k;
        value = v;
        node_level = level;
        forward = new Node<K, V>*[level + 1];
        for (int i = 0; i <= level; i++) {
            forward[i] = nullptr;
        }
    }
    
    ~Node() {
        delete[] forward;
    }
};
```

**å·®å¼‚åˆ†æ**ï¼š
- åŸé¡¹ç›®ä½¿ç”¨ `private` å°è£… key å’Œ valueï¼Œæä¾› getter/setter
- æˆ‘ä»¬çš„å®ç°æ›´ç®€æ´ï¼Œç›´æ¥ä½¿ç”¨ `public`
- ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥ï¼ŒåŸé¡¹ç›®æ›´ç¬¦åˆé¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™

---

## 3. å…³é”®è®¾è®¡å†³ç­–

### 3.1 å¤´èŠ‚ç‚¹ï¼ˆå“¨å…µèŠ‚ç‚¹ï¼‰

**ä¸ºä»€ä¹ˆéœ€è¦å¤´èŠ‚ç‚¹ï¼Ÿ**

```cpp
// æ²¡æœ‰å¤´èŠ‚ç‚¹ï¼šéœ€è¦ç‰¹æ®Šå¤„ç†ç©ºé“¾è¡¨
if (list == nullptr) {
    list = new_node;
} else {
    // æ’å…¥é€»è¾‘
}

// æœ‰å¤´èŠ‚ç‚¹ï¼šç»Ÿä¸€å¤„ç†
header->forward[0] = new_node;  // å§‹ç»ˆæœ‰æ•ˆ
```

**åŸé¡¹ç›®çš„å®ç°**ï¼š

```cpp
SkipList(int max_level) {
    this->_max_level = max_level;
    this->_skip_list_level = 0;
    this->_element_count = 0;
    
    // åˆ›å»ºå¤´èŠ‚ç‚¹ï¼Œkey å’Œ value ä¸ºé»˜è®¤å€¼
    K k;
    V v;
    this->_header = new Node<K, V>(k, v, _max_level);
}
```

### 3.2 éšæœºå±‚æ•°ç”Ÿæˆ

**åŸé¡¹ç›®çš„å®ç°**ï¼š

```cpp
int get_random_level() {
    int k = 1;
    while (rand() % 2) {
        k++;
    }
    k = (k < _max_level) ? k : _max_level;
    return k;
}
```

**æ³¨æ„**ï¼šåŸé¡¹ç›®ä» 1 å¼€å§‹ï¼Œæˆ‘ä»¬ä» 0 å¼€å§‹ã€‚ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥ï¼Œä½†è¦ä¿æŒä¸€è‡´ã€‚

### 3.3 å†…å­˜ç®¡ç†

**åŸé¡¹ç›®çš„ææ„å‡½æ•°**ï¼š

```cpp
~SkipList() {
    if (_file_writer.is_open()) {
        _file_writer.close();
    }
    if (_file_reader.is_open()) {
        _file_reader.close();
    }
    
    // é€’å½’åˆ é™¤è·³è¡¨é“¾æ¡
    if(_header->forward[0] != nullptr){
        clear(_header->forward[0]);
    }
    delete(_header);
}

void clear(Node<K, V>* cur) {
    if(cur->forward[0] != nullptr){
        clear(cur->forward[0]);
    }
    delete(cur);
}
```

**æˆ‘ä»¬çš„å®ç°**ï¼š

```cpp
~SkipList() {
    Node<K, V>* current = header->forward[0];
    while (current != nullptr) {
        Node<K, V>* temp = current;
        current = current->forward[0];
        delete temp;
    }
    delete header;
}
```

**å·®å¼‚**ï¼š
- åŸé¡¹ç›®ä½¿ç”¨é€’å½’åˆ é™¤
- æˆ‘ä»¬ä½¿ç”¨è¿­ä»£åˆ é™¤
- è¿­ä»£æ–¹å¼æ›´å®‰å…¨ï¼ˆé¿å…æ ˆæº¢å‡ºï¼‰

---

## 4. å®Œæ•´é¡¹ç›®ç»“æ„

### æ–‡ä»¶ç»„ç»‡

```
skiplist-project/
â”œâ”€â”€ skiplist.h              # è·³è¡¨æ ¸å¿ƒå®ç°
â”œâ”€â”€ main.cpp                # æ¼”ç¤ºç¨‹åº
â”œâ”€â”€ stress_test.cpp         # å‹åŠ›æµ‹è¯•
â”œâ”€â”€ makefile                # ç¼–è¯‘è„šæœ¬
â”œâ”€â”€ store/                  # æ•°æ®å­˜å‚¨ç›®å½•
â”‚   â””â”€â”€ dumpFile           # æŒä¹…åŒ–æ–‡ä»¶
â””â”€â”€ README.md              # é¡¹ç›®è¯´æ˜
```

### Makefile

```makefile
CXX = g++
CXXFLAGS = -std=c++11 -Wall -O2
LDFLAGS = -pthread

TARGET = bin/main
STRESS_TEST = bin/stress_test

all: $(TARGET)

$(TARGET): main.cpp skiplist.h
	mkdir -p bin
	mkdir -p store
	$(CXX) $(CXXFLAGS) -o $(TARGET) main.cpp

stress: stress_test.cpp skiplist.h
	mkdir -p bin
	$(CXX) $(CXXFLAGS) $(LDFLAGS) -o $(STRESS_TEST) stress_test.cpp

clean:
	rm -rf bin/*
	rm -rf store/*

.PHONY: all stress clean
```

---

## 5. ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬ä½¿ç”¨

```cpp
#include "skiplist.h"

int main() {
    // åˆ›å»ºè·³è¡¨ï¼Œæœ€å¤§å±‚æ•°ä¸º 6
    SkipList<int, string> skipList(6);
    
    // æ’å…¥æ•°æ®
    skipList.insert(1, "ä¸€");
    skipList.insert(3, "ä¸‰");
    skipList.insert(7, "ä¸ƒ");
    
    // æŸ¥æ‰¾æ•°æ®
    skipList.search(3);  // æ‰¾åˆ°
    skipList.search(5);  // æœªæ‰¾åˆ°
    
    // åˆ é™¤æ•°æ®
    skipList.delete_element(3);
    
    // æ˜¾ç¤ºè·³è¡¨
    skipList.display_list();
    
    // æ•°æ®æŒä¹…åŒ–
    skipList.dump_file();
    
    // åŠ è½½æ•°æ®
    skipList.load_file();
    
    // è·å–å¤§å°
    cout << "å¤§å°: " << skipList.size() << endl;
    
    return 0;
}
```

---

## 6. è¿›é˜¶åŠŸèƒ½

### 6.1 èŒƒå›´æŸ¥è¯¢

```cpp
// æŸ¥æ‰¾ [start, end] èŒƒå›´å†…çš„æ‰€æœ‰å…ƒç´ 
void range_query(K start, K end) {
    Node<K, V>* current = header;
    
    // æ‰¾åˆ° >= start çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
    for (int i = current_level; i >= 0; i--) {
        while (current->forward[i] != nullptr && 
               current->forward[i]->key < start) {
            current = current->forward[i];
        }
    }
    
    current = current->forward[0];
    
    // éå† [start, end] èŒƒå›´
    while (current != nullptr && current->key <= end) {
        cout << current->key << ":" << current->value << endl;
        current = current->forward[0];
    }
}
```

### 6.2 æ‰¹é‡æ’å…¥

```cpp
void batch_insert(vector<pair<K, V>>& data) {
    for (auto& p : data) {
        insert(p.first, p.second);
    }
}
```

### 6.3 è¿­ä»£å™¨æ”¯æŒ

```cpp
class Iterator {
    Node<K, V>* current;
    
public:
    Iterator(Node<K, V>* node) : current(node) {}
    
    Iterator& operator++() {
        if (current) {
            current = current->forward[0];
        }
        return *this;
    }
    
    pair<K, V> operator*() {
        return {current->key, current->value};
    }
    
    bool operator!=(const Iterator& other) {
        return current != other.current;
    }
};

Iterator begin() {
    return Iterator(header->forward[0]);
}

Iterator end() {
    return Iterator(nullptr);
}
```

---

## 7. é”™è¯¯å¤„ç†

### 7.1 å¼‚å¸¸å®‰å…¨

```cpp
void insert(K key, V value) {
    try {
        // æ’å…¥é€»è¾‘
        Node<K, V>* new_node = new Node<K, V>(key, value, random_level);
        // ...
    } catch (bad_alloc& e) {
        cerr << "å†…å­˜åˆ†é…å¤±è´¥: " << e.what() << endl;
        throw;
    }
}
```

### 7.2 è¾“å…¥éªŒè¯

```cpp
bool is_valid_key(K key) {
    // æ ¹æ®å®é™…éœ€æ±‚éªŒè¯ key
    return true;
}

void insert(K key, V value) {
    if (!is_valid_key(key)) {
        cerr << "æ— æ•ˆçš„ key: " << key << endl;
        return;
    }
    // ...
}
```

---

## 8. æµ‹è¯•ç”¨ä¾‹

### 8.1 å•å…ƒæµ‹è¯•

```cpp
void test_insert() {
    SkipList<int, string> list(6);
    
    list.insert(1, "one");
    assert(list.size() == 1);
    
    list.insert(2, "two");
    assert(list.size() == 2);
    
    list.insert(1, "duplicate");  // åº”è¯¥å¤±è´¥
    assert(list.size() == 2);
    
    cout << "âœ“ æ’å…¥æµ‹è¯•é€šè¿‡" << endl;
}

void test_search() {
    SkipList<int, string> list(6);
    
    list.insert(1, "one");
    list.insert(2, "two");
    
    assert(list.search(1) == true);
    assert(list.search(2) == true);
    assert(list.search(3) == false);
    
    cout << "âœ“ æŸ¥æ‰¾æµ‹è¯•é€šè¿‡" << endl;
}

void test_delete() {
    SkipList<int, string> list(6);
    
    list.insert(1, "one");
    list.insert(2, "two");
    list.insert(3, "three");
    
    list.delete_element(2);
    assert(list.size() == 2);
    assert(list.search(2) == false);
    
    cout << "âœ“ åˆ é™¤æµ‹è¯•é€šè¿‡" << endl;
}

void run_all_tests() {
    test_insert();
    test_search();
    test_delete();
    cout << "\næ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼" << endl;
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–æ€»ç»“

### å·²å®ç°çš„ä¼˜åŒ–

1. **éšæœºå±‚æ•°**ï¼šå¹³è¡¡æŸ¥æ‰¾æ•ˆç‡å’Œç©ºé—´å¼€é”€
2. **å¤´èŠ‚ç‚¹**ï¼šç®€åŒ–è¾¹ç•Œæ¡ä»¶å¤„ç†
3. **æŒ‡é’ˆæ•°ç»„**ï¼šé«˜æ•ˆçš„å¤šå±‚ç´¢å¼•
4. **äº’æ–¥é”**ï¼šä¿è¯çº¿ç¨‹å®‰å…¨

### å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–

1. **å†…å­˜æ± **ï¼šå‡å°‘å†…å­˜åˆ†é…å¼€é”€
2. **è¯»å†™é”**ï¼šæé«˜å¹¶å‘è¯»æ€§èƒ½
3. **æ— é”å®ç°**ï¼šä½¿ç”¨ CAS æ“ä½œ
4. **å‹ç¼©å­˜å‚¨**ï¼šå‡å°‘ç£ç›˜ç©ºé—´å ç”¨

---

## 10. ä¸åŸé¡¹ç›®å¯¹æ¯”

### ç›¸åŒç‚¹

- âœ… æ ¸å¿ƒç®—æ³•ä¸€è‡´
- âœ… æ•°æ®ç»“æ„è®¾è®¡ç›¸åŒ
- âœ… åŠŸèƒ½å®Œæ•´æ€§ç›¸å½“

### ä¸åŒç‚¹

| ç‰¹æ€§ | åŸé¡¹ç›® | æˆ‘ä»¬çš„å®ç° |
|------|--------|-----------|
| å°è£…æ€§ | æ›´ä¸¥æ ¼ï¼ˆprivateï¼‰ | æ›´ç®€æ´ï¼ˆpublicï¼‰ |
| å†…å­˜ç®¡ç† | é€’å½’åˆ é™¤ | è¿­ä»£åˆ é™¤ |
| ä»£ç é£æ ¼ | ç”Ÿäº§çº§ | æ•™å­¦çº§ |
| æ³¨é‡Š | è¾ƒå°‘ | è¯¦ç»† |

---

## 11. å­¦ä¹ æˆæœæ£€éªŒ

### ä½ åº”è¯¥èƒ½å¤Ÿå›ç­”ï¼š

1. **è·³è¡¨çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä»€ä¹ˆï¼Ÿ**
   - å¤šå±‚ç´¢å¼•ï¼ŒåŠ é€ŸæŸ¥æ‰¾

2. **ä¸ºä»€ä¹ˆè·³è¡¨çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(log n)ï¼Ÿ**
   - æ¯å±‚çº¦æœ‰å‰ä¸€å±‚ 50% çš„èŠ‚ç‚¹ï¼Œéœ€è¦ log n å±‚

3. **è·³è¡¨ç›¸æ¯”çº¢é»‘æ ‘çš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ**
   - å®ç°ç®€å•ï¼Œæ”¯æŒèŒƒå›´æŸ¥è¯¢ï¼Œå¹¶å‘å‹å¥½

4. **å¦‚ä½•å®ç°çº¿ç¨‹å®‰å…¨çš„è·³è¡¨ï¼Ÿ**
   - ä½¿ç”¨äº’æ–¥é”ä¿æŠ¤å…±äº«æ•°æ®

5. **æ•°æ®æŒä¹…åŒ–çš„åŸºæœ¬æ€è·¯æ˜¯ä»€ä¹ˆï¼Ÿ**
   - å°† Level 0 çš„æ•°æ®å†™å…¥æ–‡ä»¶ï¼ŒåŠ è½½æ—¶é‡å»ºç´¢å¼•

---

## 12. é¡¹ç›®æ‰©å±•æ–¹å‘

### 12.1 åˆ†å¸ƒå¼å­˜å‚¨

- æ·»åŠ  Raft ä¸€è‡´æ€§åè®®
- å®ç°æ•°æ®åˆ†ç‰‡
- æ”¯æŒä¸»ä»å¤åˆ¶

### 12.2 ç½‘ç»œæœåŠ¡

- æ·»åŠ  HTTP æœåŠ¡å™¨
- å®ç° REST API
- æ”¯æŒè¿œç¨‹è®¿é—®

### 12.3 é«˜çº§åŠŸèƒ½

- äº‹åŠ¡æ”¯æŒ
- å¿«ç…§å’Œæ¢å¤
- æ•°æ®å‹ç¼©
- è¿‡æœŸæ—¶é—´ï¼ˆTTLï¼‰

---

## 13. æ¨èå­¦ä¹ èµ„æº

### ä¹¦ç±

1. **ã€Šç®—æ³•å¯¼è®ºã€‹**ï¼šè·³è¡¨çš„ç†è®ºåŸºç¡€
2. **ã€ŠC++ Primerã€‹**ï¼šC++ è¯­è¨€æ·±å…¥å­¦ä¹ 
3. **ã€Šæ•°æ®åº“ç³»ç»Ÿå®ç°ã€‹**ï¼šå­˜å‚¨å¼•æ“è®¾è®¡

### å¼€æºé¡¹ç›®

1. **Redis**ï¼šä½¿ç”¨è·³è¡¨å®ç°æœ‰åºé›†åˆ
2. **LevelDB**ï¼šGoogle çš„ KV å­˜å‚¨å¼•æ“
3. **RocksDB**ï¼šFacebook çš„ KV å­˜å‚¨å¼•æ“

### åœ¨çº¿èµ„æº

1. **ä»£ç éšæƒ³å½•**ï¼šæœ¬é¡¹ç›®ä½œè€…çš„ç®—æ³•æ•™ç¨‹
2. **å¡ç ç½‘**ï¼šKV å­˜å‚¨å¼•æ“å®æˆ˜è¯¾
3. **GitHub**ï¼šæœç´¢ skiplist ç›¸å…³é¡¹ç›®

---

## 14. æ€»ç»“

### ä½ å·²ç»æŒæ¡äº†ï¼š

- âœ… è·³è¡¨çš„åŸç†å’Œå®ç°
- âœ… C++ æ¨¡æ¿ç¼–ç¨‹
- âœ… æ–‡ä»¶ I/O æ“ä½œ
- âœ… å¤šçº¿ç¨‹ç¼–ç¨‹
- âœ… æ€§èƒ½æµ‹è¯•æ–¹æ³•
- âœ… æ•°æ®ç»“æ„è®¾è®¡æ€æƒ³

### ä¸‹ä¸€æ­¥å»ºè®®ï¼š

1. **æ·±å…¥å­¦ä¹  Redis**ï¼šçœ‹çœ‹ç”Ÿäº§çº§è·³è¡¨æ˜¯å¦‚ä½•å®ç°çš„
2. **å­¦ä¹  LevelDB**ï¼šäº†è§£ LSM-Tree å­˜å‚¨å¼•æ“
3. **å®ç°åˆ†å¸ƒå¼ç‰ˆæœ¬**ï¼šæ·»åŠ  Raft åè®®
4. **å‚ä¸å¼€æºé¡¹ç›®**ï¼šä¸º Redisã€RocksDB ç­‰é¡¹ç›®è´¡çŒ®ä»£ç 

---

## 15. ç»“è¯­

æ­å–œä½ å®Œæˆäº†æ•´ä¸ªå­¦ä¹ è®¡åˆ’ï¼ğŸ‰

é€šè¿‡è¿™ 8 ä¸ªé˜¶æ®µçš„å­¦ä¹ ï¼Œä½ ä»é›¶å¼€å§‹å®ç°äº†ä¸€ä¸ªå®Œæ•´çš„ KV å­˜å‚¨å¼•æ“ã€‚è¿™ä¸ä»…æ˜¯å¯¹è·³è¡¨æ•°æ®ç»“æ„çš„æ·±å…¥ç†è§£ï¼Œæ›´æ˜¯å¯¹ç³»ç»Ÿè®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€å¹¶å‘ç¼–ç¨‹çš„å…¨é¢å®è·µã€‚

**è®°ä½**ï¼š
- ç¼–ç¨‹æ˜¯ä¸€é—¨å®è·µçš„è‰ºæœ¯
- ç†è§£åŸç†æ¯”è®°ä½ä»£ç æ›´é‡è¦
- æŒç»­å­¦ä¹ ï¼Œä¸æ–­è¿›æ­¥

ç¥ä½ åœ¨ç¼–ç¨‹ä¹‹è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼ğŸ’ª

---

## é™„å½•ï¼šå®Œæ•´ä»£ç æ¸…å•

æ‰€æœ‰é˜¶æ®µçš„ä»£ç éƒ½åœ¨ `learning-plan/` ç›®å½•ä¸‹ï¼š

- `stage1_simple_list.cpp` - å•å±‚é“¾è¡¨
- `stage2_two_level.cpp` - åŒå±‚è·³è¡¨
- `stage3_multi_level.cpp` - å¤šå±‚è·³è¡¨
- `stage5_persistence.h` - æŒä¹…åŒ–ç‰ˆæœ¬
- `stage6_thread_safe.h` - çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬
- `stage7_benchmark.cpp` - æ€§èƒ½æµ‹è¯•

åŸé¡¹ç›®ä»£ç åœ¨æ ¹ç›®å½•ï¼š
- `skiplist.h` - å®Œæ•´å®ç°
- `main.cpp` - æ¼”ç¤ºç¨‹åº
- `stress-test/stress_test.cpp` - å‹åŠ›æµ‹è¯•

